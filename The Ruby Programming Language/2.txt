-------------------------------------------------------------------------------
# Вся эта строка является комментарием
x = "#Это строка"               # А это комментарий
y = /#Это регулярное выражение/ # Это еще один комментарий

При многострочных комментариях в начале каждой строки ставиться обычно отдельный
отдельный символ #:

#
# Это многострочный комментарий.
# Это его продолжение.
#
-------------------------------------------------------------------------------
В Ruby поддерживается другой стиль многострочного комментария, известный как
встроенный документ. Начинается с =begin, заканчивается =end.

=begin Нужно выключить следующий код!
  Любой код, расположенный здесь, будет закомментирован.
=end

# =begin Так начинается комментарий. Эта строка сама себя закомментировала.
  Расположенный здесь код уже не будет закомментирован.
# =end

Обычно встроенные документы предназначены для применения некоторыми
инструментальными средствами постобработки, использующими исходный код Ruby,
и для них характерным продолжением =begin является идентификатор, указывающий
на тот инструмент, для которого написан комментарий.
-------------------------------------------------------------------------------
Описание rdoc можно получить в файле lib/rdoc/README исходного кода Ruby.

Комментарии, используемые для документирования, должны распологаться
непосредственно перед тем модулем, классом или методом, чей API они документируют.

=begein rdoc (Если опустить "rdoc", то инстументальное средство rdoc не станет
обрабатывать этот комментарий.)

#
# Комментарии rdoc используют простую грамматику разметки, подобную той, что
# используется в википедиях.
#
# Разделение абзацев производиться пустой строкой.
#
# = Заголовки
#
# Заголовки начинаются со знака равенства.
#
# == Подзаголовки
# Показанная выше строка создает подзаголовок.
# === Более глубокий подзаголовок
# И т. д.
#
# = Примеры
#
#    Строки с отступом используются, чтобы точно отобразить начертание кода.
#      Но для заголовков и списков отсутпы лучше не использовать.
#
# = Списки и шрифты
#
# Список элементов начинается с * или -. Шрифты задаются знаками пунктуации или
# HTML:
# * _курсив_ или <i>несколько слов, отмеченных курсивом</i>
# * *полужирный* или <b>несколько слов, отмеченных полужирным шрифтом</b>
# * +код+ или <tt>несколько слов, в формате кода</tt>
#
# 1. Пронумерованные списки начинаются с номера.
# 99. Можно использовать любой номер, последовательность соблюдать необязательно.
# 1. Способ вложения списков отсутствует.
#
# Пункты списка описаний заключаются в квадратные скобки:
# [Пункт 1] Описание пункта 1
# [Пункт 2] Описание пункта 2
#
-------------------------------------------------------------------------------
Литералы - это значения, непосредственно появляющиеся в исходном коде Ruby. Это
могут быть числа, текстовые строки и регулярные выражения.

1       # Целочисленный литерал
1.0     # Литерал в виде числа с плавающей точкой
'one'   # Строковый литерал
"two"   # Еще один строковый литерал
/three/ # Литерал в виде регулярного выражения
-------------------------------------------------------------------------------
Идентификатор - это обычное имя. Ruby использует идентификаторы для присваивания
имен переменным, методам, классам и т. д. Идентификаторы состоят из букв, цифр и
символов подчеркивания, но они не могут начинаться с цифры. Многострочные
идентификаторы пишуться через знак подчеркивания (snake notation). Все показанное
ниже является идентификторами.

i
x2
old_value
_internal
PI
-------------------------------------------------------------------------------
$files    # Глобальная переменная
@data     # Переменная экземпляра
@@counter # Переменная класса
empty?    # Метод или предикат, возвращающий булево значение
sort!     # Метод мутатор, изменяющий сам объект
timeout=  # Метод, вызываемый присваиванием
-------------------------------------------------------------------------------
Следующие ключевые слова имеют в Ruby специальное назначение и рассматриваются
Ruby-парсером особым образом:

__LINE__      case       ensure  not     then
__ENCODING__  class      false   or      true
__FILE__      def        for     redo    undef
BEGIN         defindef?  if      rescue  unless
END           do         in      retry   until
alias         else       module  return  when
and           elsif      next    self    while
begin         end        nil     super   yield
break

Ключевые слова, которые рассматриваются особым образом если стоят в начале
строки:

=begin  =end  __END__
-------------------------------------------------------------------------------
Многие важные свойства языка Ruby фактически реализованы как методы классов
Kernel, Module, Class и Object. Поэтому неплохо былы бы взять за правило также
рассматривать в качестве зарезервированных следующий идентификаторы:

# Это методы, которые представляются операторами или ключевыми словами
at_exit        catch    private    require
attr           include  proc       throw
attr_accessor  lambda   protected
attr_reader    load     public
attr_writer    loop     raise

# Это широко используемые глобальные функции
Array         chomp!  gsub!      select
Float         chop    iterator?  sleep
Integer       chop!   load       split
String        eval    open       sprintf
URI           exec    p          srand
abort         exit    print      sub
autoload      exit!   printf     sub!
autoload?     fail    putc       syscall
binding       fork    puts       system
block_given?  format  rand       test
callcc        getc    readline   trap
caller        gets    readlines  warn
chomp         gsub    scan

# Это широко используемые методы объекта
allocate  freeze        kind_of?     superclass
clone     frozen?       method       taint
display   hash          methods      tainted?
dup       id            new          to_a
enum_for  inherited     nil?         to_enum
eql?      inspect       object_id    to_s
equal?    instance_of?  respond_to?  untaint
extend    is_a?         send
-------------------------------------------------------------------------------
total = name_1 + name_2 \
  + name_3 + name_4        # В строке выше опреатор не завершается

animals = Array.new
  .push('dog')
  .push('cow')
  .push('cat')
  .sort
-------------------------------------------------------------------------------
Основным элементом синтаксиса Ruby является выражение. Интерпретатор Ruby
вычисляет выражения, выдавая значения. Простейшими выражениями являются первичные
выражения, которые представляют собой сами значения. Числовые и строковые
литералы - это первичные выражения. Также true, false, nil, self, ссылки на
переменные. Более сложные значения:

[1, 2, 3]              # Литерал массива
{ 1: 'one', 2: 'two' } # Литерал хэша
1..3                   # Литерал диапозона
-------------------------------------------------------------------------------
Ruby-программы имеют блочную структуру. Блоки могут быть ограничены фигурными
скобками или ключевыми словами do и end:

3.times { print 'I am block' }

1.upto(10) do |x|
  puts "I'm #{x} block"
end

module Stats                          # Модуль
  class Dataset                       # Класс в модуле
    def initialize(filename)          # Метод в классе
      IO.foreach(filename) do |line|  # Блок в методе
        if line[0, 1] == '#'          # Оператор if в блоке
          next                        # Простой оператор в if
        end                           # Завершение тела if
      end                             # Завершение блока
    end                               # Завершение тела метода
  end                                 # Завершение тела класса
end                                   # Завершение тела модуля
-------------------------------------------------------------------------------
На самом низшем уровне Ruby-программа - это простая последовательность символов.
-------------------------------------------------------------------------------
В Ruby имеется пять встроенных классов для представления чисел, а стандартная
библиотека включает еще три числовых класса, которые в отдельных случаях тоже
могут оказаться полезными.

                         +---------+
                         | Numeric |
                         +----+----+
                              |
     +-----------+------------+---------------+--------------+
     |           |            |               |              |
+----+----+  +---+---+  +-----+-----+  +------+-----+  +-----+-----+
| Integer |  | Float |  |  Complex  |  | BigDecimal |  | Rational  |
+----+----+  +-------+  | (Std Lib) |  |  (Std Lib) |  | (Std Lib) |
     |                  +-----------+  +------------+  +-----------+
     +----------+
     |          |
+----+---+ +----+---+
| Fixnum | | Bignum |
+--------+ +--------+

Все числовые объекты в Ruby являются экземплярами класса Numeric. Все
целочисленные объекты - экземплярами класса Integer. Если целочисленное
значение умещается в 31 бит, объект является экземпляром класса Fixnum. В инном
случае этот объект является экземпляром класса Bignum. Классы Complex, BigDecimal
и Rational не встроены в Ruby, но распростарняются вместе с ним как часть
стандартной библиотеки. Все числовые объекты являются неизменяемыми.
-------------------------------------------------------------------------------
Целочисленные литералы - это простая последовательность цифр:

0
123
1234567890134
1_000_000_000

Числа начинающиеся с 0x или 0X, являются шестнадцатеричными (по основанию 16),
и в них в качестве цифр от 10 до 15 используются буквы от a до f (или от A до F).
Числа, начинающиеся с 0b или 0B, являются двоичными (по основанию 2) и включают
в себя только цифры 0 и 1. Числа начинающиеся с 0 и не имеющие последующей буквы
являются восьмеричными (по основанию 8) и должны состоять из цифр от 0 до 7.

0377        # Восьмеричное представление числа 255
0b1111_1111 # Двоичное представление числа 255
0xFF        # Шестнадцатеричное представление числа 255
-------------------------------------------------------------------------------
Литералы чисел с плавающей точкой:

0.0
-3.14
6.02e23      # Это означает 6.02 x 10^23
1_000_000.01 # Число чуть больше миллиона
-------------------------------------------------------------------------------
x = 5/2   # Результат - 2
x = 5.0/2 # Результат - 2.5
x = 5/2.5 # Результат - 2.5

x = 1/0     # Возвращает ZeroDivisionError
x = 1.0/0   # Возвращает Infinity (бесконечность)
x = 0.0/0.0 # Возвращает NaN (Not a Number)

x = 5 % 2     # Результат - 1
x = 1.5 % 0.4 # Результат - 0.3

Важным следствием определения целочисленного деления в Ruby является то, что в
нем -a/b равняется a/-b, но может не равнятся -(a/b).

x**4         # То же самое, что и x*x*x*x
x**-1        # То же самое, что и 1/x
x**(1/3.0)   # То же самое, что и x
x**(1/4)     # Ничего не получиться! Целочисленное деление означает, что мы имеем
             # дело с выражением, эквивалентным x**0, которое всегда равно 1
x**(1.0/4.0) # Это корень четвертой степени из x

Когда операции возведения в степень объединены в одном выражении, они вычисляются
справа налево. Поэтому 4**3**2 равно 4**9, а не 64**2.

even = (x[0] == 0) # Число является четным, если найменее значимый бит равен 0
-------------------------------------------------------------------------------

