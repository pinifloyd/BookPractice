-------------------------------------------------------------------------------
В Ruby имеется пять встроенных классов для представления чисел, а стандартная
библиотека включает еще три числовых класса, которые в отдельных случаях тоже
могут оказаться полезными.

                         +---------+
                         | Numeric |
                         +----+----+
                              |
     +-----------+------------+---------------+--------------+
     |           |            |               |              |
+----+----+  +---+---+  +-----+-----+  +------+-----+  +-----+-----+
| Integer |  | Float |  |  Complex  |  | BigDecimal |  | Rational  |
+----+----+  +-------+  | (Std Lib) |  |  (Std Lib) |  | (Std Lib) |
     |                  +-----------+  +------------+  +-----------+
     +----------+
     |          |
+----+---+ +----+---+
| Fixnum | | Bignum |
+--------+ +--------+

Все числовые объекты в Ruby являются экземплярами класса Numeric. Все
целочисленные объекты - экземплярами класса Integer. Если целочисленное
значение умещается в 31 бит, объект является экземпляром класса Fixnum. В инном
случае этот объект является экземпляром класса Bignum. Классы Complex, BigDecimal
и Rational не встроены в Ruby, но распростарняются вместе с ним как часть
стандартной библиотеки. Все числовые объекты являются неизменяемыми.
-------------------------------------------------------------------------------
Целочисленные литералы - это простая последовательность цифр:

0
123
1234567890134
1_000_000_000

Числа начинающиеся с 0x или 0X, являются шестнадцатеричными (по основанию 16),
и в них в качестве цифр от 10 до 15 используются буквы от a до f (или от A до F).
Числа, начинающиеся с 0b или 0B, являются двоичными (по основанию 2) и включают
в себя только цифры 0 и 1. Числа начинающиеся с 0 и не имеющие последующей буквы
являются восьмеричными (по основанию 8) и должны состоять из цифр от 0 до 7.

0377        # Восьмеричное представление числа 255
0b1111_1111 # Двоичное представление числа 255
0xFF        # Шестнадцатеричное представление числа 255
-------------------------------------------------------------------------------
Литералы чисел с плавающей точкой:

0.0
-3.14
6.02e23      # Это означает 6.02 x 10^23
1_000_000.01 # Число чуть больше миллиона
-------------------------------------------------------------------------------
x = 5/2   # Результат - 2
x = 5.0/2 # Результат - 2.5
x = 5/2.5 # Результат - 2.5

x = 1/0     # Возвращает ZeroDivisionError
x = 1.0/0   # Возвращает Infinity (бесконечность)
x = 0.0/0.0 # Возвращает NaN (Not a Number)

x = 5 % 2     # Результат - 1
x = 1.5 % 0.4 # Результат - 0.3

Важным следствием определения целочисленного деления в Ruby является то, что в
нем -a/b равняется a/-b, но может не равнятся -(a/b).

x**4         # То же самое, что и x*x*x*x
x**-1        # То же самое, что и 1/x
x**(1/3.0)   # То же самое, что и x
x**(1/4)     # Ничего не получиться! Целочисленное деление означает, что мы имеем
             # дело с выражением, эквивалентным x**0, которое всегда равно 1
x**(1.0/4.0) # Это корень четвертой степени из x

Когда операции возведения в степень объединены в одном выражении, они вычисляются
справа налево. Поэтому 4**3**2 равно 4**9, а не 64**2.

even = (x[0] == 0) # Число является четным, если найменее значимый бит равен 0
-------------------------------------------------------------------------------
Текст представлен в Ruby объектами класса String. Строки являются изменяемыми
объектами. Текстовые шаблоны в Ruby представлены как объекты Regexp.
-------------------------------------------------------------------------------
Простейшие строковые литералы заключаются в одинарные кавычки. Текст внутри
кавычек является значением строки:

'Это простейший строковый литерал Ruby'

'a\b' == 'a\\b'

'Это длинный строковый литерал. \
Включающий символы обратного слэша и новой строки.'

message =
  'Эти три литерала ' \
  'объединяются интерпретатором в один. ' \
  'В получившейся строке не содержится символов новой строки.'
-------------------------------------------------------------------------------
Строковые литералы, заключенные в двойные кавычки, ведут себя более гибко, чем
литералы в одинарных кавычках.

"360 градусов = #{2*Math::PI} радианов" #=> "360 градусов = 6.2831 радианов"

$salutation = 'Hello' # Определение глобальной переменной
"#$salutation world"  # Ее использование в строке в двойных кавычках

sprintf("Значение pi примерно равно %.4f", Math::PI)
  #=> "Значение pi примерно равно 3.1416"
"Значение pi примерно равно %.4f" % Math::PI
  #=> "Значение pi примерно равно 3.1416"

"Этот строковый литерал
содержит две строки, \
хотя записан в трех."

"Этот строковый объект содержит три строки.\r\n" \
"Он записан в виде трех смежных литералов,\r\n" \
"разделенных нейтрализованными символами новой строки. \r\n"
-------------------------------------------------------------------------------
Последовательность %q служит началом для строки, которая следует правилам
строки, заключенной в одинарные кавычки, а последовательность %Q (или просто %)
представляет литерал, который следует правилам строки, заключенной в двойные
кавычки. Первый символ, следующий за q или Q, является символом-ограничителем.

%q(Don't worry about escaping ' characters!) # Нейтрализация символа ' не нужна
%Q|Он спросил: "Как дела?"|
%-Этот строковый литерал завершается символом новой строки \n- # Тут Q опущен
-------------------------------------------------------------------------------
Here-документы начинаются с последовательности << или <<-.

document = <<HERE # Начало here-документа
Это строковый литерал.
Он состоит из двух строк и неожиданно обрывается...
HERE

Если here-документ начинается с <<, то ограничитель должен находиться в начале
строки. Если вместо этого литерал начинается с <<-, то ограничитель может иметь
перед собой свободное пространство.
-------------------------------------------------------------------------------
Выполнить комманду из ОС:

`ls -la`   # Выполнить комманду с среде *nix, вернет содержимое каталога.
%x[ls -la] # То же, что и выше, но текст внутри [] обрабатывается как "". Можно
           # вставить произвольное Ruby-выражение.
-------------------------------------------------------------------------------
Когда Ruby-нтерпретатору встречается строковый литерал, он создает новый объект.
Чтобы не снижать эффективность работы программы, следует избегать использования
литералов внутри циклов.
-------------------------------------------------------------------------------
Отдельные символы могут включаться в Ruby-программы буквально, если перед ними
поставить знак вопроса, при этом отпадает необходимость использовать кавычки:

?A # Символьный литерал для ASCII-символа A
?" # Символьный литерал для символа двойной кавычки
?? # Символьный литерал для знака вопроса
-------------------------------------------------------------------------------
planet = 'Земля'
"Привет," + " " + planet #=> 'Привет, Земля'
"Привет, #{planet}"      #=> 'Привет, Земля'
"Привет, " << planet     #=> 'Привет, Земля'

alphabet = "A"  #=> "A"
alphabet << ?B  #=> "AB"
alphabet << 67  #=> "ABC"
alphabet << 256 #=> Ruby 1.8 выдаст ошибку: коды должны быть >= 0 и < 256

ellipsis = '.' * 3 #=> '...'

Операторы == и != сравнивают строки на равенство и неравенство. Две строки будут
равны лишь в том случае, когда у них одинаковая длина и все символы равны.
Операторы <, <=, >, >= сравнивают относительный порядок построения строк путем
сопоставления кодов символов, составляющих эти строки. Сравнение основано строго
на кодах символов.
-------------------------------------------------------------------------------
s = 'hello'   # Ruby 1.8
s[0]          # 104: код ASCII-символа первой буквы 'h'
s[s.length-1] # 111: код последнего символа 'o'
s[-1]         # 111: код последнего символа 'o'
s[-2]         # 108: второй с конца символ
s[-s.length]  # 104: первый символ
s[s.length]   # nil: символов с таким индексом не существует

s = 'hello'   # Ruby 1.9
s[0]          # 'h': первый символ строки, возвращенный в виде строки
s[s.length-1] # 'o': последний символ 'o'
s[-1]         # 'o': последний символ 'o'
s[-2]         # 'l': второй с конца символ
s[-s.length]  # 'h': первый символ
s[s.length]   # nil: символов с таким индексом не существует

s[0]  = ?H       # Замена первого символа на заглавную H
s[-1] = ?O       # Замена последнего символа на заглавную O
s[s.length] = ?! # Ошибка: Присваивание за пределами строки невозможно

s[0, 2]  # 'he'
s[-1, 1] # 'o'
-------------------------------------------------------------------------------
Массивы представляют собой последовательность значений, позволяющую иметь к этим
значениям доступ по их позициям, по индексам, выстроенным в последовательность.
Отрицательные значения индексов отсчитываются с конца массива, поэтому к
последнему элементу массива можно получить доступ по индексу -1. Массивы в Ruby
не типизированы и изменяемы.

[1, 2, 3]               # Массив, содержащий три объекта Fixnum
[-10...0, 0..10]        # Массив из двух диапозонов
[[1, 2], [3,4], [5, 6]] # Массив из вложенных массивов
[x+y, x-y, x*y]         # Элементы массива могут быть произвольными выражениями
[]                      # Пустой массив имеет нулевой размер

%w[this is a test] #=> ['this', 'is', 'a', 'test']
%w| ( [ { < |      #=> ['(', '[', '{', '<']
%W(\s \t \r \n)    #=> ["\s", "\t", "\r", "\n"]

Литерал массива вводиться с помощью последовательностей %w и %W, которые во многом
схожи с %q и %Q, с помощью которых вводился литерал String. Массив можно также
создать с помощью конструктора Array.new, что дает возможность программной
инициализации элементов массива:

array = Array.new                  # []: возвращает пустой массив
nils = Array.new(3)                # [nil, nil, nil]: новый массив из трех
                                   # элементов nil
zeros = Array.new(4, 0)            # [0, 0, 0, 0]: новый массив из четырех
                                   # элементов 0
copy = Array.new(nils)             # Создание новой копии существующего массива
count = Array.new(3) { |i| i + 1 } # [1, 2, 3]: Три элемента, вычисленные из
                                   # индекса

a = [1, 2, 3] + [4, 5] #=> [1, 2, 3, 4, 5]
a = a + [[6, 7, 8]]    #=> [1, 2, 3, 4, 5, [6, 7, 8]]

['a', 'b', 'c', 'b', 'a'] - ['b', 'c', 'd'] #=> ['a', 'a']

a = []         #=> []
a << 1         #=> [1]
a << 2 << 3    #=> [1, 2, 3]
a << [4, 5, 6] #=> [1, 2, 3, [4, 5, 6]]

a = [0] * 8 #=> [0, 0, 0, 0, 0, 0, 0, 0]

Класс Array позаимствовал булевы опрераторы | и & и использует их для объединения
и логического произведения. Оператор | объединяет свои аргументы в цепочку, а
затем удаляет из результата все дубликаты. Оператор & возвращает массив, который
содержит элементы, появляющиеся в обоих массивах. Возвращаемый массив не содержит
дубликатов:

a = [1, 1, 2, 2, 3, 3, 4]
b = [5, 5, 4, 4, 3, 3, 2]

a | b #=> [1, 2, 3, 4, 5]
b | a #=> [5, 4, 3, 2, 1]

a & b #=> [2, 3, 4]
b & a #=> [4, 3, 2]

a = ('A'..'Z').to_a    # Массив букв
a.each { |x| print x } # Вывод алфавита
-------------------------------------------------------------------------------
Хэши являются структурой данных, поддерживающей набор объектов, известных как
ключи, и связывающей с каждым ключом какое-нибудь значение. Хэши известны также
как отображения, поскольку они отображают ключи на значения. Иногда их называют
ассоциативными массивами, поскольку они связывают (ассоциируют) значения с
каждым из ключей и могут рассматриваться как массивы, в которых в качестве
индекса может использоваться не целое число, а любой объект.

# Этот хэш отобразит названия цифр на сами цифры
numbers = Hash.new                    # Создание нового пустого хэш-объекта
numbers['one'] = 1                    # Отображение строки "едицица" на Fixnum 1
numbers['two'] = 2
sum = numbers['one'] + numbers['two'] # Извлечение значений
-------------------------------------------------------------------------------
Хэш-литералы записываются в виде списка заключенных в фигурные скобки пар
ключ-значение, которые разделяются запятыми.

numbers = { one: 1, two: 2 }

Обозначения - это неизменяемые изолированные строки, записываемые как
идентификаторы и начинающиеся с двоеточия (:one).
-------------------------------------------------------------------------------
Хэши в Ruby реализованы с помощью структуры данных, называемой хэш-таблицей.
Если два ключа равны друг другу, у них должен быть один и тот же хэш-код.
-------------------------------------------------------------------------------
Объект Range представляет значения, расположенные между начальным и конечным
значениями. Литералы диапозона записываются путем помещения между начальным и
конечным значениями двух или трех точек. Если используются две точки, диапазон
является включающим и конечное значение является частью диапазона. Если
используются три точки, то диапазон является исключающим и конечное значение не
является частью диапазона.

1..10  # Целые числа между 1 и 10, включая 10
1...10 # Целые числа между 1 и 10, исключая 10

При определении диапазон подразумевается принцип упорядоченности. Главное
предназначение диапазона - сопоставление: возможность определения, где находится
значение, внутри или за его пределами. Второе важное предназначение - итерация.
Диапазоны, которые могут подвергаться итерации через .succ, являются дискретными.
Диапазоны, у классов крайних точек которых не определен метод .succ, не могут
подвергаться итерации, и их называют сплошными. Диапазоны с целочисленными
крайними точками являются дискретными, а с крайними значениями из чисел с
плавающей точкой называются сплошными.

Код присваивает литерал диапазона переменной, а затем вызывает методы, применяемые
к диапазону, через эту переменную. Если нужно вызвать метод напрямую к литералу
диапазона, то литерал нужно взять в круглые скобки.

1..3.to_a   # Попытка вызвать to_a для числа 3
(1..3).to_a # [1, 2, 3]
-------------------------------------------------------------------------------
По первому определению значение x принадлежит диапазону begin..end (с двумя
точками), если: begin <= x <= end. И x принадлежит диапазону begin...end (с тремя
точками), если: begin <= x < end. Это называется проверкой на принадлежность к
сплошному диапазону.

Второе определение принадлежности, относящееся к дискретному диапазону, зависит
от наличия метода .succ. По этому определению принадлежность к диапазону является
набором элементов и значение x включается в диапазон только в том случае, если
оно представляет собой значение, возвращенное одним из вызовов метода .succ.

Ruby 1.8:
r = 0...100     # Диапазон от 1 до 99
r.member? 50    # true: 50 принадлежит диапазону
r.include? 100  # false: 100 лежит за пределами диапазона
r.include? 99.9 # true: 99.9 меньше, чем 100

triples = 'AAA'..'ZZZ'
triples.include? 'ABC'       # true: работает быстро в 1.8 и медленно в 1.9
triples.inclide? 'ABCD'      # true в 1.8 и false в 1.9
triplse.cover? 'ABCD'        # Выдает true и работает быстро в 1.9
triples.to_a.include? 'ABCD' # Выдает false и работает медленно в 1.8 и 1.9
-------------------------------------------------------------------------------
Стандартная реализация Ruby-интерпретатора содержит таблицу обозначений, в
которой хранятся имена всех классов, методов и переменных, о которых что либо
известно.

:symbol       # Литерал обозначения
:"symbol"     # Тот же самый литерал
:'symbol too' # Для обознаяений с пробелами можно использовать цитаты

s = 'string'
sym = :"#{s}" # Обозначение :string

У обозначений также имеется синтаксис литерала %s, позволяющий использовать
произваольные ограничители, наподобии %q и %Q:

%s["] #=> :'"'

Обозначения часто используются для ссылок на имена методов в рефлексивном коде:

object.respond_to? :each

Проверка, отзывается ли данный объект на указанный метод, и если это так, то
метода вызывается:

name = :size
object.send(name) if object.respond_to? name

str = 'string'    # Начнем с объекта String
sym = str.intern  # Превращение в обозначение
sym = str.to_sym  # Еще один способ
str = sym.to_s    # Обратное превращение в строку
str = sym.id2name # Еще один способ

Два отличающихся друг от друга Symbol-объекта всегда будут иметь различное
содержимое. Сравнение на равенство двух Symbol-объектов выполняется намного
быстрее, чем такое же сравнение двух строк.
-------------------------------------------------------------------------------
Ключевые слова true и false являются двумя булевыми значениями, которые
представляют истину и ложь. Ключевое слово nil является специальным значением,
зарезервированным для указания отсутствия какого-либо значения.

Класс Boolean в Ruby отсутствует.

Когда Ruby требуется булево значение, nil ведет себя как false, а любое
значение, отличное от nil или false, ведет себя как true.
-------------------------------------------------------------------------------
Ruby является чистейшим объектно-ориентированным языком: все значения являются
объектами, и нет никакой разницы между элементарными типами и типами объектов,
как это бывает во многих других языках. В Ruby все объекты наследуются из
класса по имени Object и совместно используют методы, определяемые для этого
класса.
-------------------------------------------------------------------------------
При работе с Ruby-объеками мы фактически имеем дело со ссылками на объекты.
Работа ведется не с самим объектом, а со ссылкой на него. Когда переменной
присваивается какое-то значение, то объект не копируется "в" эту переменную; в
ней просто сохраняется ссылка на объект.

s = 'Ruby' # Создание строкового объекта. Сохранение ссылки на него в s.
t = s      # Копирование ссылки в t. И s, и t ссылаются на один и тот же объект.
t[-1] = '' # Изменение объекта через ссылку, хранящуюся в t.
print s    # Доступ к измененному объекту через ссылку s. Выводится 'Rub'.
t = 'Java' # Теперь t ссылается на другой объект.
print s, t # Выводится 'RubJava'.

Когда в Ruby объект передается методу, то на самом деле ему передается ссылка.
Аргументы метода передаются по значению, а не по ссылке, но в этих значениях
передаются ссылки на объект. По скольку ссылки на объект передаются методам, те
могут использовать эти ссылки для внесения изменений в исходный объект. Затем,
когда метод возвращает управление, эти изменения становяться видимыми.
-------------------------------------------------------------------------------
В Ruby используется технология под названием сборка муссора, предназначенная для
автоматического уничтожения объектов, надобность в которых уже миновала. Объекты
становяться кандидатами на применение к ним сборки мусора, когда они недоступны,
когда на объект уже не осталось ссылок за исключением тех, что исходят от других
недоступных объектов.
-------------------------------------------------------------------------------
Для определения класса объекта существует несколько способов. Самый простой из
них - запросить этот класс:

o = 'test' # Это значение
o.class    # Возвращает объект, представляющий класс String

o.class                       # String: o - это объект класса String
o.class.superclass            # Object: надкласс для String - это Object
o.class.superclass.superclass # nil: У объекта нет надкласса

В Ruby 1.9 у класса Object есть надкласс: BasicObject.

o.class == String     # true, если "о" является экземпляром класса String
o.instance_of? String # То же самое

x = 1                  # Значение с которым будем работать
x.instance_of? Fixnum  # true: является экземпляром класса
x.instance_of? Numeric # false: наследственность не проверяется
x.is_a? Fixnum         # true: x относиться к Fixnum
x.is_a? Integer        # true: x относиться к Integer
x.is_a? Numeric        # true: x относиться к Numeric
x.is_a? Comparable     # true: работает так же с миксин-модулями
x.is_a? Object         # истина для любого значения x

В Ruby у каждого объекта есть однозначно определенный класс, и этот класс никогда
не изменяется на всем протяжении времени существования объекта. С другой стороны
тип, объекта имеет более изменчивый характер. Тип объекта зависит от его класса,
но класс объекта - это всего лишь состовляющая типа объекта. Если речь идет о
типе объекта, то подразумевается совокупность признаков его поведения,
характеризующих этот объект. Другими словами, тип объекта - это набор методов,
на которые он может реагировать.

Фокусировка внимания на типах, а не классах, ведет к стилю программирования,
использующему типизацию по общим признакам, известную в Ruby как "duck-типизация"
(утиная типизация).
-------------------------------------------------------------------------------
Метод equal? определяется в классе Object для проверки, ссылаются ли два значения
на один и тот же объект. Для любых двух отличных друг от друга объектов этот
метод всегда возвращает false:

a = 'Ruby'     # Одна ссылка на один String-объект
b = c = 'Ruby' # Две ссылки на другой String-объект
a.equal? b     # false: а и b относяться к разным объектам
b.equal? c     # true: b и c ссылаются на один и тот же объект

a.object_id == b.object_id # Работает так же как и a.equal? b
-------------------------------------------------------------------------------
Оператор == является наиболее распространненным способом проверки равенства. В
классе Object - это просто синоним метода equal?, и он проверяет две ссылки на
объект на идентичность. Во многих классах этот оператор переопределяется, чтобы
дать воможность отдельным экземплярам быть проверенным на равенство:

a = 'Ruby' # Объект String
b = 'Ruby' # Еще один объект String с тем же содержимым
a.equal? b # false: a и b не ссылаются на один и тот же объект
a == b     # true: два различных объекта имеют равные значения
-------------------------------------------------------------------------------
Оператор === часто называют case-равенством, и он используется для проверки,
совпадает ли заданное значение оператора case какому-нибудь предложению when
этого оператора.

В большинстве случаев === опертор выполняет ==. Для Range оператор === определен
чтобы проверять, попадает значение в диапазон или нет. Для Regexp оператор ===
определен, чтобы проверять соответсвует строка регулярному выражению или нет. А
для Class опретор === определен, чтобы проверять, является ли объект экземпляром
класса или нет. В Ruby 1.9 для Symbol оператор === определен, чтобы вернуть true
если правосторонний операнд является тем же обозначением, которое представлено в
качестве левостороннего операнда или если он является строкой, содержащий тот же
текст.

(1..10) === 5   # true: 5 ледит в диапазоне 1..10
/\d+/ === '123' # true: строка соответствует регулярному выражению
String === 's'  # true: 's' является экземпляром класса String
:s === 's'      # true в Ruby 1.9
-------------------------------------------------------------------------------
Оператор =~ определен для классов String и Regexp (и Symbol в Ruby 1.9) для
выполнения сопоставления с шаблоном, но на самом деле он не является оператором
равенства. Для класса Object оператор =~ всегда возвращает false.
-------------------------------------------------------------------------------
Явнве методы преобразования: to_s, to_i, to_f и to_a, предназначенные для
преобразования в строку - String, в целое число - Integer, в число с плавающей
точкой - Float, и в массив - Array.
-------------------------------------------------------------------------------
В классе Object определены два тесно связанных друг с другом метода,
предназначенные для копирования объектов. Оба они, и clone и dup, возвращают
поверхностную копию объекта, для которого они вызываются. Если копируемый объект
включает в себя какую-то внутреннюю структуру, ссылающуюся на другие объекты, то
копируются только ссылки на объекты, а не сами объекты, на которые сделаны ссылки.
Если для копируемого объекта определен метод initialize_copy, то clone и dup,
просто выделяют новый, пустой экземпляр класса и вызывают для этого экземпляра
метод initialize_copy.

У методов clone и dup, определенных для Object, есть два важных различия. Первое
состоит в том, что clone копирует как состояние замороженности, так и помеченности
объекта, в то время как dup копирует лишь состояние помеченности; вызов dup в
отношении замороженных объектов приводит к возвращению незамороженной копии. А
второе состоит в том, что clone копирует любые синглтон-методы объекта, а dup -
нет.
-------------------------------------------------------------------------------
Состояние объекта можно сохранить, передав его методу класса Marshal.dump. Чтобы
востановить маршилизованный объект, нужно передать содержащую его строку или
поток ввода-вывода методу Marshal.load.

Маршализация объекта - весьмы простой сохранить его состояние для дальнейшего
использования, и эти методы могут использованы для предоставления автоматического
формата файла для Ruby-программ.
-------------------------------------------------------------------------------
Любой объект может быть заморожен поутем вызова определенного для него метода
freeze. Замороженные объекты становяться неизменяемыми - ничто из их внутреннего
состояния не может быть изменено, а попытки вызвать любые определенные для них
методы-мутаторы терпят неудачу.

s = 'ice'   # Строки - изменяемые объекты
s.freeze    # Замарозка объекта
s.frozen?   # true: объект заморожен
s.upcase!   # TypeError: нельзя изменить замороженный объект
s[0] = 'ni' # TypeError: нельзя изменить замороженный объект

Замораживание объекта класса предотвращает добавление какого-нибудь метода к
этому классу.

Если объект заморожен, то он не может быть уже разморожен.
-------------------------------------------------------------------------------
Любой объект может быть помечен как ненадежный путем вызова метода taint.
Пользовательский ввод - аргументы командной строки, переменные окружения и
строки, считанные методом gets - автоматически помечаются как ненадежные.
