-------------------------------------------------------------------------------
В Ruby имеется пять встроенных классов для представления чисел, а стандартная
библиотека включает еще три числовых класса, которые в отдельных случаях тоже
могут оказаться полезными.

                         +---------+
                         | Numeric |
                         +----+----+
                              |
     +-----------+------------+---------------+--------------+
     |           |            |               |              |
+----+----+  +---+---+  +-----+-----+  +------+-----+  +-----+-----+
| Integer |  | Float |  |  Complex  |  | BigDecimal |  | Rational  |
+----+----+  +-------+  | (Std Lib) |  |  (Std Lib) |  | (Std Lib) |
     |                  +-----------+  +------------+  +-----------+
     +----------+
     |          |
+----+---+ +----+---+
| Fixnum | | Bignum |
+--------+ +--------+

Все числовые объекты в Ruby являются экземплярами класса Numeric. Все
целочисленные объекты - экземплярами класса Integer. Если целочисленное
значение умещается в 31 бит, объект является экземпляром класса Fixnum. В инном
случае этот объект является экземпляром класса Bignum. Классы Complex, BigDecimal
и Rational не встроены в Ruby, но распростарняются вместе с ним как часть
стандартной библиотеки. Все числовые объекты являются неизменяемыми.
-------------------------------------------------------------------------------
Целочисленные литералы - это простая последовательность цифр:

0
123
1234567890134
1_000_000_000

Числа начинающиеся с 0x или 0X, являются шестнадцатеричными (по основанию 16),
и в них в качестве цифр от 10 до 15 используются буквы от a до f (или от A до F).
Числа, начинающиеся с 0b или 0B, являются двоичными (по основанию 2) и включают
в себя только цифры 0 и 1. Числа начинающиеся с 0 и не имеющие последующей буквы
являются восьмеричными (по основанию 8) и должны состоять из цифр от 0 до 7.

0377        # Восьмеричное представление числа 255
0b1111_1111 # Двоичное представление числа 255
0xFF        # Шестнадцатеричное представление числа 255
-------------------------------------------------------------------------------
Литералы чисел с плавающей точкой:

0.0
-3.14
6.02e23      # Это означает 6.02 x 10^23
1_000_000.01 # Число чуть больше миллиона
-------------------------------------------------------------------------------
x = 5/2   # Результат - 2
x = 5.0/2 # Результат - 2.5
x = 5/2.5 # Результат - 2.5

x = 1/0     # Возвращает ZeroDivisionError
x = 1.0/0   # Возвращает Infinity (бесконечность)
x = 0.0/0.0 # Возвращает NaN (Not a Number)

x = 5 % 2     # Результат - 1
x = 1.5 % 0.4 # Результат - 0.3

Важным следствием определения целочисленного деления в Ruby является то, что в
нем -a/b равняется a/-b, но может не равнятся -(a/b).

x**4         # То же самое, что и x*x*x*x
x**-1        # То же самое, что и 1/x
x**(1/3.0)   # То же самое, что и x
x**(1/4)     # Ничего не получиться! Целочисленное деление означает, что мы имеем
             # дело с выражением, эквивалентным x**0, которое всегда равно 1
x**(1.0/4.0) # Это корень четвертой степени из x

Когда операции возведения в степень объединены в одном выражении, они вычисляются
справа налево. Поэтому 4**3**2 равно 4**9, а не 64**2.

even = (x[0] == 0) # Число является четным, если найменее значимый бит равен 0
-------------------------------------------------------------------------------
Текст представлен в Ruby объектами класса String. Строки являются изменяемыми
объектами. Текстовые шаблоны в Ruby представлены как объекты Regexp.
-------------------------------------------------------------------------------
Простейшие строковые литералы заключаются в одинарные кавычки. Текст внутри
кавычек является значением строки:

'Это простейший строковый литерал Ruby'

'a\b' == 'a\\b'

'Это длинный строковый литерал. \
Включающий символы обратного слэша и новой строки.'

message =
  'Эти три литерала ' \
  'объединяются интерпретатором в один. ' \
  'В получившейся строке не содержится символов новой строки.'
-------------------------------------------------------------------------------
Строковые литералы, заключенные в двойные кавычки, ведут себя более гибко, чем
литералы в одинарных кавычках.

"360 градусов = #{2*Math::PI} радианов" #=> "360 градусов = 6.2831 радианов"

$salutation = 'Hello' # Определение глобальной переменной
"#$salutation world"  # Ее использование в строке в двойных кавычках

sprintf("Значение pi примерно равно %.4f", Math::PI)
  #=> "Значение pi примерно равно 3.1416"
"Значение pi примерно равно %.4f" % Math::PI
  #=> "Значение pi примерно равно 3.1416"

"Этот строковый литерал
содержит две строки, \
хотя записан в трех."

"Этот строковый объект содержит три строки.\r\n" \
"Он записан в виде трех смежных литералов,\r\n" \
"разделенных нейтрализованными символами новой строки. \r\n"
-------------------------------------------------------------------------------
Последовательность %q служит началом для строки, которая следует правилам
строки, заключенной в одинарные кавычки, а последовательность %Q (или просто %)
представляет литерал, который следует правилам строки, заключенной в двойные
кавычки. Первый символ, следующий за q или Q, является символом-ограничителем.

%q(Don't worry about escaping ' characters!) # Нейтрализация символа ' не нужна
%Q|Он спросил: "Как дела?"|
%-Этот строковый литерал завершается символом новой строки \n- # Тут Q опущен
-------------------------------------------------------------------------------
Here-документы начинаются с последовательности << или <<-.

document = <<HERE # Начало here-документа
Это строковый литерал.
Он состоит из двух строк и неожиданно обрывается...
HERE

Если here-документ начинается с <<, то ограничитель должен находиться в начале
строки. Если вместо этого литерал начинается с <<-, то ограничитель может иметь
перед собой свободное пространство.
-------------------------------------------------------------------------------
Выполнить комманду из ОС:

`ls -la`   # Выполнить комманду с среде *nix, вернет содержимое каталога.
%x[ls -la] # То же, что и выше, но текст внутри [] обрабатывается как "". Можно
           # вставить произвольное Ruby-выражение.
-------------------------------------------------------------------------------
Когда Ruby-нтерпретатору встречается строковый литерал, он создает новый объект.
Чтобы не снижать эффективность работы программы, следует избегать использования
литералов внутри циклов.
-------------------------------------------------------------------------------
Отдельные символы могут включаться в Ruby-программы буквально, если перед ними
поставить знак вопроса, при этом отпадает необходимость использовать кавычки:

?A # Символьный литерал для ASCII-символа A
?" # Символьный литерал для символа двойной кавычки
?? # Символьный литерал для знака вопроса
-------------------------------------------------------------------------------
planet = 'Земля'
"Привет," + " " + planet #=> 'Привет, Земля'
"Привет, #{planet}"      #=> 'Привет, Земля'
"Привет, " << planet     #=> 'Привет, Земля'

alphabet = "A"  #=> "A"
alphabet << ?B  #=> "AB"
alphabet << 67  #=> "ABC"
alphabet << 256 #=> Ruby 1.8 выдаст ошибку: коды должны быть >= 0 и < 256

ellipsis = '.' * 3 #=> '...'

Операторы == и != сравнивают строки на равенство и неравенство. Две строки будут
равны лишь в том случае, когда у них одинаковая длина и все символы равны.
Операторы <, <=, >, >= сравнивают относительный порядок построения строк путем
сопоставления кодов символов, составляющих эти строки. Сравнение основано строго
на кодах символов.
-------------------------------------------------------------------------------
s = 'hello'   # Ruby 1.8
s[0]          # 104: код ASCII-символа первой буквы 'h'
s[s.length-1] # 111: код последнего символа 'o'
s[-1]         # 111: код последнего символа 'o'
s[-2]         # 108: второй с конца символ
s[-s.length]  # 104: первый символ
s[s.length]   # nil: символов с таким индексом не существует

s = 'hello'   # Ruby 1.9
s[0]          # 'h': первый символ строки, возвращенный в виде строки
s[s.length-1] # 'o': последний символ 'o'
s[-1]         # 'o': последний символ 'o'
s[-2]         # 'l': второй с конца символ
s[-s.length]  # 'h': первый символ
s[s.length]   # nil: символов с таким индексом не существует

s[0]  = ?H       # Замена первого символа на заглавную H
s[-1] = ?O       # Замена последнего символа на заглавную O
s[s.length] = ?! # Ошибка: Присваивание за пределами строки невозможно

s[0, 2]  # 'he'
s[-1, 1] # 'o'
-------------------------------------------------------------------------------
Массивы представляют собой последовательность значений, позволяющую иметь к этим
значениям доступ по их позициям, по индексам, выстроенным в последовательность.
Отрицательные значения индексов отсчитываются с конца массива, поэтому к
последнему элементу массива можно получить доступ по индексу -1. Массивы в Ruby
не типизированы и изменяемы.

[1, 2, 3]               # Массив, содержащий три объекта Fixnum
[-10...0, 0..10]        # Массив из двух диапозонов
[[1, 2], [3,4], [5, 6]] # Массив из вложенных массивов
[x+y, x-y, x*y]         # Элементы массива могут быть произвольными выражениями
[]                      # Пустой массив имеет нулевой размер

%w[this is a test] #=> ['this', 'is', 'a', 'test']
%w| ( [ { < |      #=> ['(', '[', '{', '<']
%W(\s \t \r \n)    #=> ["\s", "\t", "\r", "\n"]

Литерал массива вводиться с помощью последовательностей %w и %W, которые во многом
схожи с %q и %Q, с помощью которых вводился литерал String. Массив можно также
создать с помощью конструктора Array.new, что дает возможность программной
инициализации элементов массива:

array = Array.new                  # []: возвращает пустой массив
nils = Array.new(3)                # [nil, nil, nil]: новый массив из трех
                                   # элементов nil
zeros = Array.new(4, 0)            # [0, 0, 0, 0]: новый массив из четырех
                                   # элементов 0
copy = Array.new(nils)             # Создание новой копии существующего массива
count = Array.new(3) { |i| i + 1 } # [1, 2, 3]: Три элемента, вычисленные из
                                   # индекса

a = [1, 2, 3] + [4, 5] #=> [1, 2, 3, 4, 5]
a = a + [[6, 7, 8]]    #=> [1, 2, 3, 4, 5, [6, 7, 8]]

['a', 'b', 'c', 'b', 'a'] - ['b', 'c', 'd'] #=> ['a', 'a']

a = []         #=> []
a << 1         #=> [1]
a << 2 << 3    #=> [1, 2, 3]
a << [4, 5, 6] #=> [1, 2, 3, [4, 5, 6]]

a = [0] * 8 #=> [0, 0, 0, 0, 0, 0, 0, 0]

Класс Array позаимствовал булевы опрераторы | и & и использует их для объединения
и логического произведения. Оператор | объединяет свои аргументы в цепочку, а
затем удаляет из результата все дубликаты. Оператор & возвращает массив, который
содержит элементы, появляющиеся в обоих массивах. Возвращаемый массив не содержит
дубликатов:

a = [1, 1, 2, 2, 3, 3, 4]
b = [5, 5, 4, 4, 3, 3, 2]

a | b #=> [1, 2, 3, 4, 5]
b | a #=> [5, 4, 3, 2, 1]

a & b #=> [2, 3, 4]
b & a #=> [4, 3, 2]

a = ('A'..'Z').to_a    # Массив букв
a.each { |x| print x } # Вывод алфавита
-------------------------------------------------------------------------------

