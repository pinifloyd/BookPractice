Глава 5 - Инструкции и управляющие структуры
-------------------------------------------------------------------------------
Глава 5.1 - Условия

Условия - самая распространенная управляющая структура любого языка
программирования. Условие - это выражение, если оно вычисляется в любое
значение отличное от false или nil, то условие считается соблюденным.
-------------------------------------------------------------------------------
Глава 5.1.1.3 - Возвращаемое значение

Во многих языках if-условие является инструкцией. Но в Ruby все является
выражением, даже управляющие структуры, которые обычно называются инструкциями.
Возвращаемое значение if является значением последнего выполненного в коде
выражения или nil, если ни один из кодовых объектов не был выполнен.
-------------------------------------------------------------------------------
Глава 5.1.4 - Case

Инструкция case является условием, имеющим множественное ветвление.

case
when x == 1
  'one'
when x == 2
  'two'
when x == 3
  'three'
end

Инструкция case проверяет каждое из своих when-предложений в порядке их
написания до тех пор, пока не найдет одно из них, вычисляемое в true.
-------------------------------------------------------------------------------
Глава 5.3.5 - Внешние итераторы

Нумераторы используются как правило в качестве прокси-объектов, принадлежащих
классу Enumerable. Но в Ruby 1.9 нумераторы нашли другое очень важное
применение: они используются как внешние итераторы. Нумератор можно
использовать для последовательного перебора элементов коллекции путем
многократного вызова метода next. Если элементы заканчиваются, то этот метод
выдает исключение StopIteration.

Когда итерация управляется клиентом, итератор называется внешним,а когда она
управляется итератором - внутренним. Клиенты применяющие внешний итератор,
должны провести обработку очередного элемента и запросить следующий элемент у
итератора явным образом. В отличие от этого, внутреннему итератору клиент
передает выполняемую операцию, а затем итератор применяет это операцию к
каждому элементу.

Внешние итераторы гибче внутренних. К примеру, провести сравнение двух
коллекций с внешним итератором не составляет труда, а с внутренним итератором
это сделать практически невозможно. Но с другой стороны, внутренние итераторы
проще в использовании, поскольку сами определяют для нас логику итерации.

В Ruby методы-итераторы наподобие each являются внутренними итераторами; они
управляют итерацией и "помещают" значения в блок кода, связанный с вызовом
метода.

Пользоваться внешними итераторами довольно просто, когда нужен следующий
элемент, достаточно вызвать метод next. Когда уже не осталось ни одного
элемента, next выдает исключение StopIteration.

Параллельная итерация с использованием внешних итераторов:

# Вызов метода each по очереди для каждой коллекции.
# Это еще не паралленльная и ей требуются нумераторы.
def sequence(*enumerables, &block)
  enumerables.each do |enumerable|
    enumerable.each(&block)
  end
end

# Итерация указанных коллекций с чередованием их элементов.
# Без внешних итераторов это сделать невозможно.
def interleave(*enumerables)
  # Превращение перечисляемых коллекций в массив нумераторов.
  enumerators = enumerables.map { |e| e.to_enum }

  # Выполнение цикла, пока не закончаться нумераторы.
  until enumerators.empty?
    begin
      e = enumerators.shift    # Получить первый нумератор.
      yield e.next             # Взять его значение next и передать блоку.
    rescue StopIteration       # Если элементы закончились, ничего не делать.
    else                       # Если исключения не выдано,
      enumerators << e         # вернуть нумератор.
    end
  end
end

# Итерация указанных коллекций, передача набора значений по одному из каждой
# коллеции.
def bundle(*enumerables)
  enumerators = enumerables.map { |e| e.to_enum }
  loop { yield enumerators.map{ |e| e.next } }
end

# Примеры работы этих методов-итераторов:
a, b, c = [1, 2, 3], 4..6, ?a..?e
sequence(a, b, c) { |x| print x }   #=> "123456abcde"
interleave(a, b, c) { |x| print x } #=> "14a25b36cde"
bundle(a, b, c) { |x| print x }     #=> "[1, 4, 'a'][2, 5, 'b'][3, 6, 'c']"
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------

