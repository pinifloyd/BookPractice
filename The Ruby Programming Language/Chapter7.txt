Глава 7 - Классы и модули.

Ruby-объекты обладают обсолютной инкапсуляцией: доступ к их состоянию может
быть получен только через определенные в них методы. Есть возможность
определения методов доступа, которые играют роли получателей и установщиков и
создают впечатление, что доступ к состоянию объекта ведется напрямую. Эти пары
методов доступа известны как атрибуты, и они отличаются от переменных
экземпляра.
-------------------------------------------------------------------------------
Глава 7.1.7 - Доступ к массивам и хэшам с помощью метода [].

Для доступа к массивам и хэшам используются квадратные скобки и любому классу
разрешается определить метод [] и использовать квадратные скобки по своему
усмотрению. Определение метода [], позволяющего Point (класс в качестве
примера) походить на массив или хэш с ключами :x, :y :
def [](index)
  case index
  when 0, -2: @x   # Индекс 0 (или -2) указывает на координату Х
  when 1, -1: @y   # Индекс 1 (или -1) указывает на координату У
  when :x, 'x': @x # Ключ хэша для Х в виде обозначения или строки
  when :y, 'y': @y # Ключ хэша для У в виде обозначения или строки
  else nil         # При неприемлимых индексах масивы и хэши возвращают nil
  end
end
-------------------------------------------------------------------------------
Глава 7.2 - Область видимости методов: открытые, защищенные и закрытые методы.

Методы экземпляров могут быть открытыми (public), закрытыми (private) или
защищенными (protected).

Методы обычно бывают открытыми, пока они не будут явным образом объявлены
закрытими или защищенными. Открытые методы могут быть вызваны отовсюду - на их
использование ограничения не накладываются.

Закрытый метод является внутренним по отношению к реализации класса, и он может
быть вызван только другими экземплярами методов этого класса (или из
подклассов). Подразумевается, что закрытые методы вызываются в отношении
self-объекта и не могут быть вызваны в отношении объекта явным образом.

Защищенные методы определяются реже всех остальных, и в них к тому же довольно
трудно разобраться. Правило, обпределяющее, когда защищенный метод может быть
вызван, более формально может быть описано так: защищенный метод, определенный
классом С, может быть вызван в отношении объекта о методом в объекте р только в
том случае, если классы, к которым относятся о и р, оба являются подклассами,
или самим классом С.
-------------------------------------------------------------------------------
Глава 7.4.3 - Dup, clone и initialize_copy.

Если вызвать dup и clone, то будет распределена память под новый экземпляр
класса того объекта, в отношении которого они вызваны. Затем они копируют все
переменные экземпляра и все содержимое объекта-получателя во вновь
распределенный объект. Метод clone идет при копировании чуть дальше, чем метод
dup - он копирует также синглтон-методы объекта-получателя и замораживает копию
объекта, если оригинал был заморожен.

Если в классе определен метод по имени initialize_copy, то clone и dup вызовут
этот метод в отношении копируемого объекта после копирования переменных
экземпляра из оригинала. Метод clone вызывает initialize_copy до заморозки
копии объекта.

Эти методы копируют ссылки на значения переменных.
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
