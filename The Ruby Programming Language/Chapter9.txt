Глава 9.6.1 - Имена файлов и каталогов.

full = '/home/matz/bin/ruby.exe'
file = File.basename(full)     #=> 'ruby.exe'
File.basename(full, '.exe')   #=> 'ruby'
dir = File.dirname(full)      #=> '/home/matz/bin'
File.dirname(file)             #=> '.'
File.split(full)              #=> ['/home/matz/bin', 'ruby.exe']
File.extname(full)            #=> '.exe'
File.extname(file)             #=> '.exe'
File.extname(dir)             #=> ''
File.join('home', 'matz')     #=> 'home/matz'
File.join('', 'home', 'matz') #=> '/home/matz'

Dir.chdir('/usr/bin')
File.expand_path('ruby')                   #=> '/usr/bin/ruby'
File.expand_path('~/ruby')                 #=> '/home/david/ruby'
File.expand_path('~matz/ruby')             #=> '/home/matz/ruby'
File.expand_path('ruby', '/usr/local/bin') #=> '/usr/local/bin/ruby'
File.expand_path('ruby', '../local/bin')   #=> '/usr/local/bin/ruby'
File.expand_path('ruby', '~/bin')          #=> '/home/david/bin/ruby'

File.identical? возвращает лишь true, если два имени ссылаются на один и тот же
файл и этот файл существует.

File.identical?('ruby', 'ruby')          #=> true, если файл существует
File.identical?('ruby', '/usr/bin/ruby') #=> true, если текущий рабочий каталог
                                         #=> /usr/bin
File.identical?('ruby', '../bin/ruby')   #=> true, если текущий рабочий каталог
                                         #=> /usr/bin
File.identical?('ruby', 'ruby1.9')       #=> true, если это ссылка
-------------------------------------------------------------------------------
Глава 9.6.2 - Вывод содержимого каталогов.

Простейшим способом вывода содержимого каталога является использование метода
Dir.entries или итератора Dir.foreach:

# Получение имен всех файлов, имеющихся в каталоге config/
filenames = Dir.entries('config')         # Получение имен в виде массива
Dir.foreach('config') { |filename| ... }  # Перебор имен

Dir.glob('*.rb') { |f| ... }      # Перебор всех Ruby-файлов
Dir.glob('*')                     # Фалы с именами, начинающимися '.', не
                                  # входят
Dir.glob('*', File::FNM_DOTMATCH) # Все файлы (открытые и скрытые)

puts Dir.getwd          # Текущий рабочий каталог
Dir.chdir('..')         # Изменение текущего каталога на родительский каталог
Dir.chdir('../sibling') # Переход в каталог-потомок
Dir.chdir('/home')      # Переход в /home
Dir.chdir               # Переход в домашний каталог пользователя
home = Dir.pwd          # Псевдоним getwd

Если методу chdir передать блок, то при выходе из него исходное значение
каталога будет востановленно. Но при этом следует отметить, что хотя изменение
каталога ограниченно по времени, оно имеет глобальную область видимости и
оказывает влияние на другие потоки выполнения. Два потока не вправе
одновременно вызывать Dir.chdir с блоком.
-------------------------------------------------------------------------------
Глава 9.6.3 - Проверка файлов.

f = '/usr/bin/ruby' # Имя файла для показанных ниже примеров

File.exist?(f)     # Есть ли такой файл?
File.file(f)        # Это существующий файл?
File.directory?(f) # Это существующий каталог?
File.symlink?(f)   # В обоих случаях является ли это символьной ссылкой?

File.size(f)  # Размер файла в байтах
File.size?(f) # Размер файла в байтах или nil, если файл пустой
File.zero?(f) # True если файл пустой

File.readable?(f)       # Доступен ли файл для чтения?
File.writable?(f)       # Доступен ли файл для записи?
File.executable?(f)     # Исполняемый файл?
File.world_readable?(f) # Общедоступен для чтения?
File.world_writable?(f) # Общедоступен для записи?

File.mtime?(f) # Время последнего изменения в виде Time-объекта
File.atime?(f) # Время последнего доступа в виде Time-объекта

File.ftype('/usr/bin/ruby')   # 'link'
File.ftype('/usr/bin/ruby1.9) # file
File.ftype('/usr/lib/ruby)    # directory
File.ftype('/usr/bin/ruby3.0) # SystemCallError

Эфективность использования метода stat в том, что Ruby обращается один раз к
системе, затем данные беруться из объекта File::Stat.

s = File.stat('/usr/bin/ruby')
s.file?        # true
s.directory?  # false
s.ftype       # 'file'
s.readable?   # true
s.writable?   # false
s.executable? # true
s.size        # 5492
s.atime       # Time

Метода Kernel.test
test ?e, '/usr/bin/ruby' # File.exist?('/usr/bin/ruby')
test ?f, '/usr/bin/ruby' # File.file?('/usr/bin/ruby')
test ?d, '/usr/bin/ruby' # File.directory?('/usr/bin/ruby')
test ?r, '/usr/bin/ruby' # File.readable?('/usr/bin/ruby')
test ?w, '/usr/bin/ruby' # File.writable?('/usr/bin/ruby')
test ?m, '/usr/bin/ruby' # File.mtime('/usr/bin/ruby')
test ?s, '/usr/bin/ruby' # File.size?('/usr/bin/ruby')
-------------------------------------------------------------------------------
Глава 9.6.4 - Создание, удаление и переименование файлов.


File.open('test', 'w') { } # Создание (или перезапись) файла "test"
File.open('test', 'a') { } # Создание без перезаписи файла "test"

File.rename('test', 'test.old')     # Переименование файла
File.symlink('test.old', 'oldtest') # Создание символьной ссылки
File.link('test.old', 'test2')      # Создание жесткой ссылки
File.delete('test2')                # Удалить файл или ссылку

f = 'log.messages'
atime = mtime = Time.now
File.truncate(f, 0)         # Удалить содержимое файла
File.utime(atime, mtime, f) # Изменение атрибутов времени
File.chmod(0600, f)         # Права доступа
-------------------------------------------------------------------------------
Глава 9.7.5 - Методы произвольного доступа.

f = File.open('test.txt')
f.pos                     # 0: текущая позиция в байтах
f.pos = 10                # переход к позиции 10
f.tell                    # 10: синоним для pos
f.rewind                  # возвращение к позиции 0, сбрасывает счетчик строк в 0
f.seek(10, IO::SEEK_SET)  # Переход к абсолютной позиции 10
f.seek(10, IO::SEEK_CUR)  # Переход на 10 байтов от текущей позиции
f.seek(-10, IO::SEEK_END) # Переход на 10 байтов от конца
f.seek(0, IO::SEEK_END)   # Переход в конец файла
f.eof?                    # true, конец файла
-------------------------------------------------------------------------------
Глава 9.7.6 - Закрытие, сброс и тестирование потоков.

После чтения из потока или записи в него поток нужно закрыть методом close. Тем
самым будет сброшен буферизованный ввод или вывод, освободяться ресурсы ОС.
Некоторые методы используют блок кода, после завершения которого, они
автоматически закрывают и поток.

Сетевые сокеты реализуются с использованием IO-объектов, которые внутри себя
имеют раздельные потоки чтения и записи.
-------------------------------------------------------------------------------
Глава 9.8 - Работа в сети.

Клиенты интернета используют класс TCPSocket, а серверы интернета - класс
TCPServer (которые также является сокетом). Все сокет-классы являются частью
стандартной библиотеки, поэтому для использования их в Ruby-программе нужно
включить в нее следующую строку:

require 'socket'
-------------------------------------------------------------------------------
Глава 9.8.1 - Самый простой клиент.

Для создания клиентских интернет-приложений используется класс TCPSocket.
Экземпляр TCPSocket получается с помощью метода класса TCPSocket.open или его
синонима TCPSocket.new. В качестве первого аргумента идет имя узла, к которому
нужно подключиться, в качестве второго аргумента идет номер порта.

Располагая открытым сокетом, из него можно считывать данные, как из любого
другого IO-объекта. Его, как и файл, после чтения нужно закрыть. Ниже показан
простой клиент, подключающийся к заданному узлу и порту, читающий из сокета
любые доступные данные и потом выходит:

require 'socket' # Подключаем библиотеку

host, port = ARGV # Узел и порт берутся из командной строки

s = TCPSocket.open(host, port) # Открываем сокет для узла и порта

while line = s.gets # Чтение строки из сокета
  puts line.chop    # Ее вывод с признаком конца строки
end

s.close # Закрываем сокет

Тоже самое, только используем блок, для автоматического закрытия сокета:

require 'socket'

host, port = ARGV

TCPSocket.open(host, port) do |s|
  while line = s.gets
    puts line.chop
  end
end # Сокет закроется автоматически
-------------------------------------------------------------------------------
Глава 9.8.2 - Самый простой сервер.

Для создания интернет серверов используем класс TCPServer. Код ниже показывает
как можно создать простой сервер времени. Он ожидает подключения к порту 2000.
Когда клиент подключается к этому порту, он отправляет клиенту текущее время и
закрывает сокет, тем самым прерывая подключение клиента:

require 'socket'              # Подключаем библиотеку
server = TCPServer.open(2000) # Сокет для ожидания подключения к порту 2000
loop {                        # Бесконечный цикл: сервер работает вечно
  client = server.accept      # Ожидание подключения клиента
  client.puts(Time.now.ctime) # Отправка клиенту текущего времени
  client.close                # Отключение от клиента
}
-------------------------------------------------------------------------------
Глава 9.8.3 - Датаграммы.

Большинство интернет-протоколов реализуется с помощью классов TCPSocket и
TCPServer. Менее затратной альтернативой служит использование UDP-датаграмм с
помощью класса UDPSocket.

UDP дает возможность компьютерам отправлять другим компьютерам индивидуальные
пакеты данных, без издержек на установку постоянного подключения.

Пример клиента:

require 'socket'                     # Подключаем библиотеку
host, port, request = ARGV           # Получаем аргументы из коммандной строки
ds = UDPSocket.new                   # Создание сокета датаграмм
ds.connect(host, port)               # Подключение к порту на узле
ds.send(request, 0)                  # Отправка текста запроса
response.address = ds.recvfrom(1024) # Ожидаем ответ (максимум 1 Кб)
puts response                        # Вывод ответа

Пример сервера:

require 'socket'
port = ARGV[0]
ds = UDPSocket.new
ds.bind(nil, port) # Настрока сокета на ожидание подключения к порту
loop do
  request, address = ds.recvfrom(1024)  # Ожидание получения данных
  response = request.upcase             # Приводим текст к верхнему регистру
  clientaddr = address[3]               # IP запроса
  clientname = address[2]               # Имя узла
  clientport = address[1]               # Порт запроса
  ds.send \
    response, 0, clientaddr, clientport # Оптравка ответа
  puts 'Done'
end
-------------------------------------------------------------------------------
Глава 9.8.4 - Более сложный пример клиента.

Код ниже относится к более развитому интернет-клиенту в стиле telnet. Он
подключается к указанному узлу и порту, затем работает в цикле, считывает
строки входных данных с консоли, отправляет их на сервер, а затем считывает
и выводит полученный с сервера ответ.

require 'socket' # Подключаем библиотеку

host, port = ARGV # Получаем данные из командной строки

begin # используем метода begin для обработки исключений
  # Предоставление пользователю ответной информации при подключении
  STDOUT.print 'Подключение...'  # Сообщение о происходящем
  STDOUT.flush                    # Немедленное отображение
  s = TCPSocket.open(host, port) # Подключение
  STDOUT.puts 'Готово'           # Сообщение о подключении

  # Отображение информации о подключении
  local, peer = s.addr, s.peeraddr
  STDOUT.print "Осуществлено подключение к #{peer[2]}:#{peer[1]}"
  STDOUT.puts  "используется локальный порт #{local[1]}"

  # Небольшое ожидание отправки с сервера начального сообщения
  begin
    sleep(0.5)                  # Ожидание пол-секунды
    msg = s.read_nonblock(4096) # Чтение того что уже готово
    STDOUT.puts msg.chop        # И его отображение
  rescue SystemCallError
    # Если для чтения ничего не готово, то исключение игнорируется
  end

  # Начало цикла взаимодействия клиент-сервер
  loop do
    STDOUT.print '> '  # Приглашение на дисплее для локального ввода
    STDOUT.flush        # Отображение приглашения
    local = STDIN.gets # Чтение строки с консоли
    break if !local    # Переход к началу цикла если нет ввода из консоли
    s.puts(local)      # Отправка строки на сервер
    s.flush             # Принуждение к отправке

    # Чтение ответа сервера и его вывод. Сервер может послать более одной
    # строки, поэтому для чтения всего, что им послано, используется
    # readpartial, поскольку все прибывает одной порцией.
    response = s.readpartial(4096) # Чтение ответа, полученного с сервера
    puts(response.chop)            # Отображение ответа пользователю
  end
rescue         # Если что-то не получилось
  puts $!      # Отображение исключения пользователю
ensure         # Независимо от хода событий
  s.close if s # Закрываем сокет
end
-------------------------------------------------------------------------------