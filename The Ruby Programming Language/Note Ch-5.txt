Глава 5 - Инструкции и управляющие структуры
-------------------------------------------------------------------------------
Глава 5.1 - Условия

Условия - самая распространенная управляющая структура любого языка
программирования. Условие - это выражение, если оно вычисляется в любое
значение отличное от false или nil, то условие считается соблюденным.
-------------------------------------------------------------------------------
Глава 5.1.1.3 - Возвращаемое значение

Во многих языках if-условие является инструкцией. Но в Ruby все является
выражением, даже управляющие структуры, которые обычно называются инструкциями.
Возвращаемое значение if является значением последнего выполненного в коде
выражения или nil, если ни один из кодовых объектов не был выполнен.
-------------------------------------------------------------------------------
Глава 5.1.4 - Case

Инструкция case является условием, имеющим множественное ветвление.

case
when x == 1
  'one'
when x == 2
  'two'
when x == 3
  'three'
end

Инструкция case проверяет каждое из своих when-предложений в порядке их
написания до тех пор, пока не найдет одно из них, вычисляемое в true.
-------------------------------------------------------------------------------
Глава 5.3.5 - Внешние итераторы

Нумераторы используются как правило в качестве прокси-объектов, принадлежащих
классу Enumerable. Но в Ruby 1.9 нумераторы нашли другое очень важное
применение: они используются как внешние итераторы. Нумератор можно
использовать для последовательного перебора элементов коллекции путем
многократного вызова метода next. Если элементы заканчиваются, то этот метод
выдает исключение StopIteration.

Когда итерация управляется клиентом, итератор называется внешним,а когда она
управляется итератором - внутренним. Клиенты применяющие внешний итератор,
должны провести обработку очередного элемента и запросить следующий элемент у
итератора явным образом. В отличие от этого, внутреннему итератору клиент
передает выполняемую операцию, а затем итератор применяет это операцию к
каждому элементу.

Внешние итераторы гибче внутренних. К примеру, провести сравнение двух
коллекций с внешним итератором не составляет труда, а с внутренним итератором
это сделать практически невозможно. Но с другой стороны, внутренние итераторы
проще в использовании, поскольку сами определяют для нас логику итерации.

В Ruby методы-итераторы наподобие each являются внутренними итераторами; они
управляют итерацией и "помещают" значения в блок кода, связанный с вызовом
метода.

Пользоваться внешними итераторами довольно просто, когда нужен следующий
элемент, достаточно вызвать метод next. Когда уже не осталось ни одного
элемента, next выдает исключение StopIteration.

Параллельная итерация с использованием внешних итераторов:

# Вызов метода each по очереди для каждой коллекции.
# Это еще не паралленльная и ей требуются нумераторы.
def sequence(*enumerables, &block)
  enumerables.each do |enumerable|
    enumerable.each(&block)
  end
end

# Итерация указанных коллекций с чередованием их элементов.
# Без внешних итераторов это сделать невозможно.
def interleave(*enumerables)
  # Превращение перечисляемых коллекций в массив нумераторов.
  enumerators = enumerables.map { |e| e.to_enum }

  # Выполнение цикла, пока не закончаться нумераторы.
  until enumerators.empty?
    begin
      e = enumerators.shift    # Получить первый нумератор.
      yield e.next             # Взять его значение next и передать блоку.
    rescue StopIteration       # Если элементы закончились, ничего не делать.
    else                       # Если исключения не выдано,
      enumerators << e         # вернуть нумератор.
    end
  end
end

# Итерация указанных коллекций, передача набора значений по одному из каждой
# коллеции.
def bundle(*enumerables)
  enumerators = enumerables.map { |e| e.to_enum }
  loop { yield enumerators.map{ |e| e.next } }
end

# Примеры работы этих методов-итераторов:
a, b, c = [1, 2, 3], 4..6, ?a..?e
sequence(a, b, c) { |x| print x }   #=> "123456abcde"
interleave(a, b, c) { |x| print x } #=> "14a25b36cde"
bundle(a, b, c) { |x| print x }     #=> "[1, 4, 'a'][2, 5, 'b'][3, 6, 'c']"
-------------------------------------------------------------------------------
Глава 5.4.3 - Блоки и область видимости переменных

Блоки определяют новую область видимости переменных: переменные, созданные
внутри блока, существуют только в пределах этого блока и за его пределами не
определены. Но локальные переменные метода доступны любому блоку внутри этого
метода.

Ruby 1.9 отличается важным аспектом. Синтаксис блока был расширен, чтобы дать
возможность объявлять локальные переменные блока, локальность которых
гарантируется, даже если переменная с таким именем уже существует в
охватывающей блок области видимости. Для этого нужно продолжить список
параметров блока точкой с запятой (;) и списком локальных переменных блока с
запятой в качестве разделителя их имен.

x = y = 0            # Локальные переменные
1.upto(4) do |x; y|  # x и y - локальные переменные блока
  puts y = x + 1     # x и y "затенены" от внешних переменных
end
[x, y]               #=> [0, 0] - блок не изменил значения переменных
-------------------------------------------------------------------------------
Глава 5.5 - Изменение хода работы программы

return
  Приводит к выходу из метода и возвращает значение той инструкции, которая его
вызвала.

break
  Приводит к выходу из цикла (или итератора).

next
  Заставляет цикл (или итератор) пропустить оставшуюся часть текущей итерации и
и перейти к следующей итерации.

redo
  Перезапускает цикл или итерацию с самого начала.

retry
  Перезапускает итератор, заново вычисляя все выражение. Может также
использоваться при обработке исключений.

throw-catch
  Универсальная управляющая структура. Используется как своеобразная
многоуровневая или помеченная инструкция break.
-------------------------------------------------------------------------------
Глава 5.6 - Исключения и их обработка.

Исключение является объектом, предсавлющим некую разновидность исключительных
обстоятельств; оно свидетельствует о возникновении нештатного режима работы.
Для выдачи исключения используется принадлежащий классу Kernel метод raise, а
для обработки исключения используется предложение rescue. Исключения выданные
с помощью метода raise, являются экземплярами класса Exception или одного из
его многочисленных подклассов.
-------------------------------------------------------------------------------
Глава 5.6.2 - Выдача исключений с помощью raise.

Исключение выдает имеющийся в классе Kernel метод raise. Иногда, если есть
предположение, что исключение может привести к выходу из программы,
используется его синоним - метод fail. Для вызова raise существует несколько
способов:

- Если метод raise вызывается без аргументов, он создает новый объект
RunTimeError (не имеющий сообщения) и выдает исключение с этим объектом. Или же
если  raise используется без аргументов внутри предложения rescue, то просто
заново выдает обрабатываемое исключение.

- Если raise вызывается с аргументом, в качестве которого выступает
единственный объект класса Exception, он выдает это исключение.

- Если raise вызывается с единственным строковым аргументом, он создает новый
объект исключения RunTimeError с указанной строкой в качестве его сообщения и
выдает соответсвующее исключение.

- Если первым аргументом метода raise является объект, для которого определен
метод exception, то raise вызывает этот метод и выдает исключение,
соответствующее возвращенному им объекту класса Exception.

В качестве необязательного второго аргумента raise воспринимает строку. Если
строка определена, она передается методу exception в качестве его первого
аргумента. Эта строка предназначена для использования в качестве сообщения
выдаваемого исключения.
-------------------------------------------------------------------------------
Глава 5.6.3.2 - Обработка исключений по типам.

Если rescue не передать тип исключения, он обработает по умолчанию любое
исключение, относящееся к StandardError (rescue => ex). Если нужно обработать
нестандартные исключения, не входящие в иерархию StandardError, или если нужно
обработать только вполне определенные типы исключения, в предложение rescue
следует включить один или более классов исключений:

rescue Exception, ArgumentError => ex

begin
  x = factorial(1)
rescue ArgumentError => ex
  puts 'Попробуйте еще раз'
rescue TypeError => ex
  puts 'Неверный тип'
end

Ruby-интерпретатор пытается сопоставить исключения с предложениями rescue в
порядке их написания. Поэтому найболее характерные подклассы исключений должны
быть указаны в первую очередь, а за ними уже должны следовать более общие типы.
-------------------------------------------------------------------------------
Глава 5.6.3.3 - Распространение исключений

Когда выдается исключение, управление тут же передается из исходной точки и
переходит вверх до тех пор, пока не будет найдено подходящее предложение rescue
предназначенное для обработки исключения.
-------------------------------------------------------------------------------
Глава 5.6.5 - Предложение ensure

Предложение ensure содержит код, который выполняется всегда, независимо от того
что случилось с кодом, который следует за ключевым словом begin.

- Если код выполняется до конца, то управление передается предложению else,
если оно присутствует, а затем оно передается предложению ensure.

- Если код выполняет инcтрукцию возвращения - return, то при ее выполнении
пропускается предложение else и перед возвращением управление переходит к ensure.

- Если код следующий за ключевым словом begin, выдает исключение, управление
передается соответствующему предложению rescue, а затем ensure.

- Если предложения rescue отсутствуют или если ни одно из предложений rescue не
может обработать исключение, то управление передается непосредственно ensure.
Код unsure выполнятеся до того, как исключение будет распространено за пределы
охватывающих блоков или вверх по стеку вызовов.
-------------------------------------------------------------------------------
Глава 5.6.6 - Rescue в определениях метода, класса и модуля.

Следующий код является упрощенной структурой определения метода, в котором
используются предложения rescue, else и ensure:

def method_name(x)
  # Сюда помещается тело метода. Обычно тело метода выполняется до конца без
  # выдачи исключений и передает управление в место, откуда был вызван метод.
rescue
  # Сюда помещается код обработки исключения. Если в теле метода выдано
  # исключение или если один из вызываемых им методов выдал исключение,
  # управление переходит к этому блоку.
else
  # Если в теле метода не возникло исключительных ситуаций, выполняется код
  # этого предложения.
ensure
  # Код в этом предложении выполняется независимо от того, что происходит в
  # теле метода. Он запускается, если метод выполнен до конца, если он выдал
  # исключение или если он выполняет инструкцию return.
end
-------------------------------------------------------------------------------
Глава 5.8.1 - Потоки для параллельного выполнения.

Поток выполнения является последовательностью Ruby-инструкций, которые
запускаются (или производят впечатление того, что запускаются) в параллель с
основной последовательностью инструкций, выполняемых интерпретатором. Потоки
представлены объектами класса Thread.
-------------------------------------------------------------------------------
Глава 5.8.2 - Нити для сопрограмм.

В Ruby 1.9 вводится структура управления, известная как нить (fiber) и
представленная объектом класса Fiber. Нити в Ruby можно охарактеризовать как
сопрограммы, или, если выразиться точнее, как полусопрограммы. Найболее
распрастарненным примером использования сопрограмм является реализация
генераторов: объектов, которые способны вычислять частичный результат, вернуть
этот результат вызывающей программе и сохранить состояние вычисления, чтобы
вызывающая программа могла продолжить это вычисление для получения следующего
результата. В Ruby класс Fiber используется для получения автоматического
преобразования внутренних итераторов, таких как метод each, в нумераторы или
внешние итераторы.

Нить, как поток и поток, имеет тело кода. В отличие от потока, тело нити не
начинает выполняться тотчас же. Чтобы запустить нить, нужно вызвать метод
resume для объекта класса Fiber, который ее представляет. При первом вызове для
нити метода resume управление передается к началу тела нити. Затем эта нить
работает до оканчания своего тела или до того, как ею будет выполнен метод
класса Fiber.yield. Метод fiber.yield возвращает управление вызывающей
программе и совершает выход из вызова resume. Он также сохраняет состояние нити
чтобы следующий вызов resume смог подхватить нить в том состоянии, в котором
она была оставлена.

f = Fiber.new {
  puts "Начало нити"
  Fiber.yield
  puts "Конец нити"
}

puts "Начало вызывающей программы"
f.resume
puts "Конец вызывающей программы"
f.resume

#=> Начало вызывающей программы
#=> Начало нити
#=> Конец вызывающей программы
#=> Конец нити

Нити могут передавать друг другу значения с помощью метода transfer. В
дополнение к методу transfer библиотека fiber определяет также методы
экземпляра alive?, чтобы понять, находится ли тело нити в работе или нет, и
метод класса current для возвращения объекта Fiber, которому в данный момент
передано управление.
-------------------------------------------------------------------------------