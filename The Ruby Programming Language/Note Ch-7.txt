Глава 7 - Классы и модули.

Ruby-объекты обладают обсолютной инкапсуляцией: доступ к их состоянию может
быть получен только через определенные в них методы. Есть возможность
определения методов доступа, которые играют роли получателей и установщиков и
создают впечатление, что доступ к состоянию объекта ведется напрямую. Эти пары
методов доступа известны как атрибуты, и они отличаются от переменных
экземпляра.
-------------------------------------------------------------------------------
Глава 7.1.7 - Доступ к массивам и хэшам с помощью метода [].

Для доступа к массивам и хэшам используются квадратные скобки и любому классу
разрешается определить метод [] и использовать квадратные скобки по своему
усмотрению. Определение метода [], позволяющего Point (класс в качестве
примера) походить на массив или хэш с ключами :x, :y :
def [](index)
  case index
  when 0, -2: @x   # Индекс 0 (или -2) указывает на координату Х
  when 1, -1: @y   # Индекс 1 (или -1) указывает на координату У
  when :x, 'x': @x # Ключ хэша для Х в виде обозначения или строки
  when :y, 'y': @y # Ключ хэша для У в виде обозначения или строки
  else nil         # При неприемлимых индексах масивы и хэши возвращают nil
  end
end
-------------------------------------------------------------------------------
Глава 7.2 - Область видимости методов: открытые, защищенные и закрытые методы.

Методы экземпляров могут быть открытыми (public), закрытыми (private) или
защищенными (protected).

Методы обычно бывают открытыми, пока они не будут явным образом объявлены
закрытими или защищенными. Открытые методы могут быть вызваны отовсюду - на их
использование ограничения не накладываются.

Закрытый метод является внутренним по отношению к реализации класса, и он может
быть вызван только другими экземплярами методов этого класса (или из
подклассов). Подразумевается, что закрытые методы вызываются в отношении
self-объекта и не могут быть вызваны в отношении объекта явным образом.

Защищенные методы определяются реже всех остальных, и в них к тому же довольно
трудно разобраться. Правило, обпределяющее, когда защищенный метод может быть
вызван, более формально может быть описано так: защищенный метод, определенный
классом С, может быть вызван в отношении объекта о методом в объекте р только в
том случае, если классы, к которым относятся о и р, оба являются подклассами,
или самим классом С.
-------------------------------------------------------------------------------
Глава 7.4.3 - Dup, clone и initialize_copy.

Если вызвать dup и clone, то будет распределена память под новый экземпляр
класса того объекта, в отношении которого они вызваны. Затем они копируют все
переменные экземпляра и все содержимое объекта-получателя во вновь
распределенный объект. Метод clone идет при копировании чуть дальше, чем метод
dup - он копирует также синглтон-методы объекта-получателя и замораживает копию
объекта, если оригинал был заморожен.

Если в классе определен метод по имени initialize_copy, то clone и dup вызовут
этот метод в отношении копируемого объекта после копирования переменных
экземпляра из оригинала. Метод clone вызывает initialize_copy до заморозки
копии объекта.

Эти методы копируют ссылки на значения переменных.
-------------------------------------------------------------------------------
Глава 7.4.4 - marshal_dump и marshal_load.

Способо создания объектов связанный с вызовом метода marshal.load для
воссоздания объектов, которые ранее были маршализированы (или
"сериализированы", то есть переведены в последовательность) с помощью метода
marshal.dump. Метод marshal.dump сохраняет класс объекта и рекурсивно
маршализирует значение каждой из его переменных экземпляра.
-------------------------------------------------------------------------------
Глава 7.4.5 - Шаблон Синглтон (Singleton).

Синглтон - класс, у которого имеется только один экземпляр. Синглтоны могут
использоваться для хранения глобальных состояний программы внутри
объектно-ориентированной среды и могутсоставить разумную альтернативу методам
класса и переменным класса.

В Ruby к применению термина синглтон нужно проявлять особое внимание из-за его
перегруженности. Метод, добовляемый к единичному объекту, а не к классу
объектов, известен как синглтон-метод. Неявный объект класса, к которому
добавляются такие синглтон-методы, иногда называется синглтон-классом.

При реализации синглтона нужно соблюдать некоторые приемы: методы new и
allocate должны быть закрытыми, методы dup и clone не должны допускать создания
копий и так далее. Модуль Singleton, принадлежащий стандартной библиотеке,
делает эту работу за нас; нужно затребовать его строкой require 'singleton', а
затем включить Singleton в класс. Этим включение определяется метод класса
instance, не воспринимающий никаких аргументов и возвращающий
синглтон-экземпляр класса.
-------------------------------------------------------------------------------
Глава 7.5 - Модули.

Модули, как и классы, представляют собой поименованную группу методов, констант
и переменных класса. Модуль не может иметь экземпляров и не может иметь
структур аналогичных подклассам. Модули автономны, никакой иерархии модулей или
наследования не существует. Модули используются как пространство имен и как миксины (mixins). Все классы являются модулями, но не все модули являются классами. Классы, как и модули, могут использоваться как простанство имен, но классы не могут быть использованы как миксины.
-------------------------------------------------------------------------------
Глава 7.5.1 - Модули как пространства имен.

Если нет необходимости в создании экземпляров, то можно использовать модли как
пространства имен:

module Base64
  def self.encode; end
  def self.decode; end
end

Модули могут быть воложенными:

module Base64
  DIGITS = '1235....'
  
  class Encoder
    def encode; end
  end

  class Decoder
    def decode; end
  end

  def self.helper; end
end
-------------------------------------------------------------------------------
Глава 7.5.2 - Использование модулей в качестве миксинов.

Второй вариант импользования модулей  представляет собой более мощный механизм,
чем первый. Если в модуле определены не методы класса, а методы экземпляра, то
эти методы экземпляра могут быть подмешаны к другим классам. Чтобы подмешать модули к классу используется метод include. Метод extend превращает методы экземпляра указанного модуля или модулей в синглтон-методы объета получателя.
-------------------------------------------------------------------------------
Глава 7.5.3 - Включаемые модули пространства имен.

Существует возможность определения модулей, которые определяют пространство
имен, но все же позволяют своим методам быть подмешиваемыми. Если требуется
создать такой модуль (нападобие Math или Kernel), определите свои методы как
методы экземпляров модуля. Затем воспользуйтес модулем module_function для
преобразования этих методов в функции модуля.
-------------------------------------------------------------------------------
Глава 7.6.2 - Выполнение загруженного кода.

Методы load и require выполняют код сразу, содержащийся в указанном файле.

- Локальные переменные, определенные в той области видимости, из которой
вызывался метод load или require, загруженному файлу не видны.
- Любые локальные переменные, создаваемые загружаемым файлом, отбрасываются
сразу же после завершения загрузки; они не видны за пределами файла, в котором
определены.
- В начале загружаемого файла значение self всегда является основным объектом,
так же как в начале работы Ruby-интерпретатора. То есть вызов load или require
внутри вызова метода не распространяет объект-получатель на загружаемый файл.
- Текущая вложенность модуля в рамках загружаемого файла игнорируется. Можно, к
примеру, открыть класс, затем загрузить файл, содержащий определения методов.
Файл будет обработан в области видимости верхнего уровня, а не внутри
какого-нибудь класса или модуля.
-------------------------------------------------------------------------------
Глава 7.6.3 - Автоматически загружаемые модули.

Методы autoload классов Kernel и Module допускают "ленивую" загрузку по мере
необходимости.