  Уставновить свой редактор можно с помощью комманды:
git config --global core.editor
--------------------------------------------------------------------------------
  Для более подробного напоминания, что мы меняли, можно передать аргумент -v
в комманду git commit. В этом случае в комментарии будет помещена разница (diff)
наших изменений. Комментарии удаляются когда мы выходим из редактора, то есть
они только для нас, как напоминание.

  Что бы совместить коммит и добавить все файлы без промежуточных комманд можно
добавить аргумент -а в комманду git commit.
--------------------------------------------------------------------------------
  Если в комманду git log добавить аргумент -p то отобразиться еще и разница
(diff). Можно вывести краткую статистику --stat. Другой действительно полезный
параметр — это --pretty. Он позволяет изменить формат вывода лога. Нам доступны
несколько предустановленных вариантов. Параметр oneline выводит каждый коммит в
одну строку, что удобно если мы просматриваем большое количество коммитов. В
дополнение к этому, параметры short, full, и fuller, практически не меняя формат
вывода, позволяют выводить меньше или больше деталей соответственно. Наиболее
интересный параметр — это format, который позволяет нам полностью создать
собственный формат вывода лога:

$ git log --pretty=format:"%h - %an, %ar : %s"
ca82a6d - Scott Chacon, 11 months ago : changed the version number
085bb3b - Scott Chacon, 11 months ago : removed unnecessary test code
a11bef0 - Scott Chacon, 11 months ago : first commit

`%H`    Хеш коммита
`%h`    Сокращенный хеш коммита
`%T`    Хеш дерева
`%t`    Сокращенный хеш дерева
`%P`    Хеши родительских коммитов
`%p`    Сокращенные хеши родительских коммитов
`%an`   Имя автора
`%ae`   Электронная почта автора
`%ad`   Дата автора (формат соответствует параметру --date= )
`%ar`   Дата автора, относительная (пр. "2 мес. назад")
`%cn`   Имя коммитера
`%ce`   Электронная почта коммитера
`%cd`   Дата коммитера
`%cr`   Дата коммитера, относительная
`%s`    Комментарий

  Параметры oneline и format также полезны с другим параметром команды log —
--graph. Этот параметр добавляет миленький ASCII граф, показывающий историю
ветвлений и слияний.

`-p`                Выводит патч (заплатку/diff) внесенный каждым коммитом.
`--stat`            Выводит статистику по файлам измененным в каждом коммите.
`--shortstat`       Отображает только строку с changed/insertions/deletions от
                    вывода команды `--stat`.
`--name-only`       Выводит список измененных файлов после каждого коммита.
`--name-status`     Выводит список файлов вместе с информацией о
                    добавлении/изменении/удалении.
`--abbrev-commit`   Выводит только первые несколько символов контрольной суммы
                    SHA-1 вместо всех 40.
`--relative-date`   Выводит дату в относительном формате (например, “2 недели
                    назад”) вместо использования полного формата даты.
`--graph`           Выводит ASCII граф истории ветвлений и слияний рядом с
                    выводом лога.
`--pretty`          Выводит коммиты в альтернативном формате. Параметры включают
                    oneline, short, full, fuller, и format.

Параметры, ограничивающие по времени - --since и --until. Например, следующая
команда выдаёт список коммитов, сделанных за последние две недели:

$ git log --since=2.weeks

Такая команда может работать с множеством форматов — можно указать точную дату
(“2008-01-15”) или относительную дату, такую как “2 years 1 day 3 minutes ago”.

Также можно отфильтровать список коммитов по какому-либо критерию поиска. Опция
--author позволяет фильтровать по автору, опция --grep позволяет искать по
ключевым словам в сообщении. (Если указать и опцию author, и опцию grep, то
будут найдены все коммиты, которые удовлетворяют первому ИЛИ второму критерию.
Чтобы найти коммиты, которые удовлетворяют первому И второму критерию, следует
добавить опцию --all-match.)

Полезная опция-фильтр для git log — это путь. Указав имя каталога или файла, мы
ограничиваем вывод log теми коммитами, которые вносят изменения в указанные
файлы. Эта опция всегда указывается последней и обычно предваряется двумя
минусами (--), чтобы отделить пути от остальных опций.

`-(n)`                  Показать последние n коммитов
`--since`, `--after`    Ограничить коммиты теми, которые сделаны после указанной
                        даты.
`--until`, `--before`   Ограничить коммиты теми, которые сделаны до указанной
                        даты.
`--author`              Показать только те коммиты, автор которых соответствует
                        указанной строке.
`--committer`           Показать только те коммиты, коммитер которых
                        соответствует указанной строке.
--------------------------------------------------------------------------------
  Если после совершения коммита мы осознали, что забыли проиндексировать
изменения в файле, которые хотели добавить в этот коммит, или по каким-либо
другим причинам нам надо изменить последний коммит, то:

$ git commit --amend
--------------------------------------------------------------------------------
  Чтобы узнать какие у нас удаленные репозитории есть:

$ git remote -v
origin  git@github.com:pinifloyd/FocusGTD.git (fetch)
origin  git@github.com:pinifloyd/FocusGTD.git (push)

  Чтобы получить побольше информации об одном из удалённых репозиториев, можно
использовать команду git remote show [удал. сервер]:

$ git remote show origin
--------------------------------------------------------------------------------
  Просмотреть какие есть метки в репозитории можно так:

$ git tag
--------------------------------------------------------------------------------
  Чтобы посмотреть последний коммит на каждой из веток, выполним комманду:

$ git branch -v
  iss53   93b412c fix javascript issue
* master  7a98805 Merge branch 'iss53'
  testing 782fd34 add scott to the author list in the readmes

  Чтобы посмотреть те ветки, которые уже слиты с текущей, выполним комманду:

$ git branch --merged
  iss53
* master

  Чтобы посмотреть все ветки, содержащие нароботки, которые мы еще не объединили
с текущей веткой, выполним комманду:

$ git branch --no-merged
  testing

  Чтобы удалить ветку serverfix на сервере, выполним следующее:

$ git push origin :serverfix
To git@github.com:schacon/simplegit.git
 - [deleted]         serverfix

  Merge сохраняет всю историю коммитов, плюс еще один коммит слияния. То есть
будет дерево из нескольких веток и общего коммита (последний коммит-слияния).

  Rebase не сохраняет всю историю коммитов в виде дерева. Это лучше использовать
локально. Например, у меня есть ветка master и ветка develop, в которой я что-то
делал. Я переношу коммиты из develop в master, с помощью rebase. Тогда в ветке
master будут еще коммиты из develop, и не будет коммиты слияния. То есть это
будет выглядеть как последовательная работа в одной ветке.
--------------------------------------------------------------------------------
  При просмотре истории коммитов может возникнуть потребность исключить коммиты
котрые уже есть в вашей ветке. Это можно сделать добавив опцию --not перед
именем ветки:

$ git log contrib --not master

  В контексте команды diff, мы можем поставить три точки после названия одной из
веток, чтобы увидеть дельту между последним коммитом ветки, на которой мы
находимся, и их общим предком с другой веткой. Эта команда покажет вам только те
наработки в нашей текущей тематической ветке, которые были внесены после её
ответвления от ветки master:

$ git diff master...contrib
--------------------------------------------------------------------------------
  Подготовка релиза (оставляет .gitignore, .ruby-gemset, .ruby-version):

$ git archive master --prefix='project/' | gzip > `git describe master`.tar.gz
--------------------------------------------------------------------------------
  При помощи команды git shortlog можно быстро получить что-то наподобие лога
изменений (changelog)
--------------------------------------------------------------------------------
  Найболее распростарненный способ задать диапазон коммитов - это запись с двумя
точками. По существу, таким образом мы указываем Git'у взять набор коммитов
достижимых из одного коммита, но не достижимых из другого. Допустим мы хотим
посмотреть, что в ветке experiment еще не было слито в master:

$ git log master..experiment

  Еще один частый случай использования этого синтаксиса - посмотреть, что мы
собираемся отправить на удаленный сервер:

$ git log orign/master..HEAD

  Если мы хотим увидеть все коммиты достижимые из refA или refB, но не из refC,
можно набрать одну из комманд:

$ git log refA refB ^refC
$ git log refA refB --not refC

  Последняя основная запись для выбора диапазона коммитов - это запись с тремя
точками, которая означает те коммиты, которые достижимы по одной из двух ссылок,
не но по обеим одновременно:

$ git log master...experiment

  В этом случае вместе с командой log обычно используют параметр --left-right,
который показывает, на какой стороне диапазона находится каждый коммит. Это
помогает сделать данные полезнее:

$ git log --left-right master...experiment
< F
< E
> D
> C
--------------------------------------------------------------------------------
  Git stash спрячет текущее грязное состояние рабочего каталога в стек. Он
спрячет только уже отслеживаемые файлы. Посмотреть что лежит в стеке можно так:

$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051... Revert "added file_size"
stash@{2}: WIP on master: 21d80a5... added number to log

  Применить последнюю спрятанную работу можно такой коммандой:

$ git stash apply

  Если нужно применить одну из старых заначек, можете сделать это так:

$ git stash apply stash@{2}

  Всё что делает опция apply это пытается применить спрятанную работу — то, что
мы спрятали, всё ещё будет находиться в стеке. Чтобы удалить спрятанное,
нужно выполнить git stash drop с именем "заначки", которую нужно удалить.

  Git не предоставляет команды stash unapply, но можно добиться того же эффекта
получив сначала патч для спрятанных изменений, а потом применив его в
перевернутом виде:

$ git stash show -p stash@{0} | git apply -R

  Можно сделать псевдоним и добавить в git команду stash-unapply:

$ git config --global alias.stash-unapply '!git stash show -p | git apply -R'

  Если нужен простой способ снова потестировать спрятанную работу, можно
выполнить команду git stash branch, которая создаст новую ветку с началом из
того коммита, на котором мы находились во время прятанья, восстановит в ней
работу и затем удалит спрятанное, если оно применилось успешно:

$ git stash branch testchanges
--------------------------------------------------------------------------------
  Чтобы изменить сообщение последнего коммита, можно воспользоваться коммандой:

$ git commit --amend

  А если надо добавить какие-то фалы или удалить из коммита, нужно просто как
всегда (на основании этого, измениться индекс последнего коммита):

$ git add filename
$ git commit --amend
--------------------------------------------------------------------------------
  Чтобы удалить файл из всей истории коммитов нужно:

$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD

  Чтобы запустить filter-branch для всех веток, можно передать команде параметр
--all.
--------------------------------------------------------------------------------
  Иногда нужно посмотреть аннотацию к файлу. Это помогает узнать что, когда и
кем менялось в файле.

$ git blame filename

  Без ключа -C будет показан код, который использовался при инициализации этого
файла, но если было переименование или перемещение файла, то этот ключ все это
покажет.

$ git blame -C filename

  Можно так же ограничить по каким строкам искать. Делается это с помощью ключа
-L. В этом примере будут показаны строки с 1 по 5.

$ git blame -C -L 1, 5 filename
--------------------------------------------------------------------------------
  Если получилось так, что есть ошибка в проекте и мы не знаем кто и когда
сломал код, или где это и почему произошло, но можем воспроизвести ошибку, то
может помочь bisect (что-то вроде поиска по бинарному дереву, или метода деления
пополам).

  Начинаем поиск:

$ git bisect start

  Говорим что текущий коммит сломан:

$ git bisect bad

  Говорим когда было последнее известное хорошее состояние:

$ git bisect good v1.0

  Git скажет сколько было сделано коммитов с последнего хорошего состояния и
поместит нас в средний коммит. Тестируем прилажение и если тут не нашли ошибку,
говорим, что коммит не сломан: bit bisect good (bad - если ошибка), и нас снова
переместит на другой средний коммит, и так далее пока не найдем где ошибка.

  Когда закончим, нужно чтобы Git сбросил HEAD туда где он был до этого:

$ git bisect reset
--------------------------------------------------------------------------------
  Добавление внешних проектов в качестве подмодулей делается командой:

$ git submodule add

  При клонировании проекта содержащего подмодули, сами подмули не будут слиты.
Чтобы их забрать себе, нужно:

$ git submodule init
$ git submodule update
--------------------------------------------------------------------------------
  Можно попросить Git не экспортировать определенные файлы и каталоги при
создании архива. Например, в подкаталоге test/ имеются некоторые тестовые файлы,
и нет необходимости добавлять их в тарбол при экспорте проекта. Для этого
добавим строку в файл с Git-атрибутами (.gitattributes):

  test/ export-ignore

  Теперь, если запустить git archive, чтобы создать тарбол с проектом, этот
каталог не будет включен в архив.
--------------------------------------------------------------------------------
  В какой-то момент при работе с Git, мы можем нечаянно потерять коммит.

  Первый пример, когда жестко сбросили ветку в master на более ранний коммит. В
этом случае, самый быстрый способ - это использовать инструмент git reflog. Он
покажет коммиты, на которых мы когда-то находились, но информации выведет мало.
Более удобный вывод можно получить, используя git log -g, что даст стандартный
вывод лога для записей из reflog. Когда найдем коммит который мы потеряли, он
может быть востановлен созданием ветки, указывающей на него (git branch name
sha1-commit).

  Второй пример, когда потерянный коммит не попал в reflog по какой-либо
причине. В таком случае надо использовать утилиту git fsck, проверяющую бызу на
целостность. Если ей передать ключ --full, то будут показаны все объекты
недостижимые из других объектов.

$ git fsck --full
dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4
dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b
dangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9
dangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293

  В данном случае потерянный коммит указан после слов "dangling commit", что
значит "висячий коммит". Его можно востановить тем же способом - добавив ветку,
указывающую на данный коммит (sha1).
--------------------------------------------------------------------------------
  Чтобы быстро узнать сколько у нас занято места, можно воспользоваться командой
count-objects:

$ git count-objects -v
count: 4
size: 16
in-pack: 21
packs: 1
size-pack: 2016
prune-packable: 0
garbage: 0

  Запись size-pack — это размер упакованных файлов в килобайтах, то есть всего
занято 2 MБ. Перед последним коммитом, использовалось около 2 КБ, то есть,
удаление файла не удалило его из истории. Из-за того, что мы однажды случайно
добавили большой файл, при каждом клонировании этого репозитория каждому
человеку придётся скачивать все эти 2 МБ.

  Как можно определить, какие файлы занимают много места? Определить самые
крупные файлы можно запустив служебную команду git verify-pack, и отсортировав
её вывод по третьей колонке, в которой записан размер файла.

$ git verify-pack -v .git/objects/pack/pack-3f8c0...bb.idx | sort -k 3 -n \
  | tail -3
e3f094f522629ae358806b17daf78246c27c007b blob 1486    734     4667
05408d195263d853f09dca71d55116663690c27c blob 12908   3478    1189
7a9eb2fba2b1811321254ac360970fc169ba2330 blob 2056716 2056872 5401

  Чтобы узнать, что это за файл, воспользуемся командой rev-list. Если передать
ей ключ --objects, то она выдаст хеши всех коммитов, а также хеши объектов и
соответствующие им имена файлов.

$ git rev-list --objects --all | grep 7a9eb2fb
7a9eb2fba2b1811321254ac360970fc169ba2330 git.tbz2

  Теперь необходимо удалить данный файл из всех деревьев в прошлом по истории.
Легко получить все коммиты, которые меняли данный файл:

$ git log --pretty=oneline -- git.tbz2
da3f30d019005479c99eb4c3406225613985a1db oops - removed large tarball
6df764092f3e7c8f5f94cbe08ee5cf42e92a0289 added git tarball

  Необходимо переписать все коммиты, начиная с 6df76 для полного удаления
данного файла. Для этого воспользуемся командой filter-branch:

$ git filter-branch --index-filter \
   'git rm --cached --ignore-unmatch git.tbz2' -- 6df7640^..
Rewrite 6df764092f3e7c8f5f94cbe08ee5cf42e92a0289 (1/2)rm 'git.tbz2'
Rewrite da3f30d019005479c99eb4c3406225613985a1db (2/2)
Ref 'refs/heads/master' was rewritten

  Теперь история не содержит ссылок на данный файл. Однако, в reflog и в новом
наборе ссылок, добавленном Git'ом в .git/refs/original после выполнения
filter-branch, ссылки на него всё ещё присутствуют. Поэтому необходимо их
удалить, а потом переупаковать базу. Необходимо избавиться от всех возможных
ссылок на старые коммиты перед переупаковкой:

$ rm -Rf .git/refs/original
$ rm -Rf .git/logs/
$ git gc
Counting objects: 19, done.
Delta compression using 2 threads.
Compressing objects: 100% (14/14), done.
Writing objects: 100% (19/19), done.
Total 19 (delta 3), reused 16 (delta 1)

  Большой объект всё ещё хранится в одном из "рыхлых" объектов, но, что самое
важное, при любой последующей отправке данных наружу и в том числе при
клонировании он передаваться не будет. Если очень хочется, можно удалить его
навсегда локально, выполнив git prune --expire.
--------------------------------------------------------------------------------
  Поиск коммита по названию(комментарию):

git log --grep="some_string"
git log --pretty=format:"%s %H" | grep "some_string"
