Глава 6 - Методы, proc и lambda-объекты и замкнутые выражения.

Метод - это поименованный блок параметризированного кода, связанный с одним или
более объектами.

Блоки, как и методы, не являются объектами обработки в языке Ruby. Тем не менее
существует возможность создать объект, представляющий блок. Блок может быть
представлен Proc-объектом. Как и объект Method, блок кода можно выполнить
посредством представляющего его Proc-объекта. Существуют две разновидности
Proc-объектов, которые называются proc и lambda. И proc и lambda, являются
функциями, в отличие от методов, вызываемых для какого-нибдуь объекта. Важным
свойством proc и lambda является то, что они являются замкнутыми выражениями:
они сохраняют доступ к локальным переменным, которые присутствовали в области
видимости, в тот момент, когда они определялись, даже когда proc или lambda
вызываются из другой области видимости.
-------------------------------------------------------------------------------
Глава 6.1.4 - Определение синглтон-методов.

Инструкцию def можно использовать при определении метода для единственно
указанного объекта. Для этого за ключевым словом def нужно указать выражение,
вычисляемое в объект. За этим выражением должна следовать точка и имя
определяемого метода. Получающийся в результате этого метод известен как
синглтон-метод (метод, определенный в единственном экземпляре), поскольку он
доступен только в отдельно взятом объекте:

o = 'message'  # Строка, являющаяся объектом
def o.printme  # Определение для этого объекта синглтон-метода
    puts self
end
o.printme      # Вызов синглтон-метода
-------------------------------------------------------------------------------
Глава 6.4.5.1 - Использование & в вызове метода.

a, b = [1, 2, 3], [4, 5]                      # Данные
sum = a.inject(0) { |total, x| total + x }    # 6, сумма элементов массива а
sum = b.inject(sum) { |total, x| total + x }  # 15, сумма элемментов массива b
                                              # и предыдущего значения sum

Вместо того чтобы заставлять Ruby-интерпретатор дважды проводить синтаксический
анализ одного и тоже блока, можно создать Proc-объект, представляющий этот блок
и дважды воспользоваться одним и тем же Proc-объектом:

a, b = [1, 2, 3], [4, 5]                      # Данные
summation = Proc.new { |total, x| total + x } # Proc-объект для суммирования
sum = a.inject(0, &sumation)                  # 6
sum = b.inject(sum, &summation)               # 15

В Ruby 1.9 метод to_proc определен в классе Symbol, позволяя обозначениям иметь
префикс & и передаваться итераторам. Когда обозначение передается подобным
образом, то оно воспринимается как имя метода:

words = %w(and but car)                # Массив слов
uppercase = words.map(&:upcase)        # Приводим к верхнему регистру с
                                       # использованием String.upcase
uppercase = words.map { |w| w.upcase } # Или так, тоже что и выше
-------------------------------------------------------------------------------
Глава 6.5 - Proc и lambda.

Блоки в Ruby - это синтаксическая структура; они не являются объектами и с ними
нельзя работать как с объектами. В зависимости от того, как этот объект
создается, он называется proc или lambda. Объекты proc ведут себя наподобие
блоков, а объекты lambda по поведению больше напоминают методы. Но они оба
являются экземплярами класса Proc.
-------------------------------------------------------------------------------
Глава 6.5.1 - Создание Proc-объектов.

Можно связать блок с методом, который был определен с использованием
блока-аргумента, имеющего префикс в виде амперсанда. Такой метод может вернуть
Proc-объект за пределы этого метода:

# Метод создает proc из блока
def makeproc(&p) # Превращение связанного блока в Proc и сохранение его в p
  p              # Возвращение Proc-объекта
end

adder = makeproc { |x, y| x + y }

Переменная adder ссылается на Proc-объект. Proc-объекты, созданные таким
способом, относятся к proc, а не к lambda. Для всех Proc-объектов определен
метод call, при вызове которого запускается код, содержащийся в блоке, на
основании которого был создан proc.

sum = adder.call(2, 2) #=> 4
-------------------------------------------------------------------------------
Глава 6.5.1.2 - Kernel.lambda

Другая технология создания Proc-объектов связана с применением метода lambda.
Этот метод ведет себя как глобальная функция. Метод lambda не предполагает
использования аргументов, но с его вызовом должен быть связан какой-нибудь
блок:

is_positive = lambda { |x| x > 0 }
-------------------------------------------------------------------------------
Глава 6.5.1.4 - Литералы Lambda.

Две эквивалентные записи:
  succ = lambda { |x| x + 1 }
  succ = ->(x) { x + 1 }

Как и в блоках, используемых в Ruby 1.9, список параметров lambda-литерала
может включать объявление локальных переменных блока, которые защищены от
переписывания переменными с такими же именами из охватывающей области видимости. Для этого нужно продолжить список параметров точкой с запятой и
списком локальных переменных:

f = ->(x, y; i, j, k) { ... } # Принимает 2 аргумента, объявляет 3 локальные
                              # переменные

Можно обявить lambda-объект с аргументами по умолчанию:

zoom = ->(x, y, factor = 2) { [x*factor, y*factor] }
-------------------------------------------------------------------------------
Глава 6.5.2 - Вызов объектов Proc и Lambda.

Proc и Lambda являются объектами, а не методами, и они не могут быть вызваны
тем же способом, что и методы. Вызов метода call приводит к выполнению кода
исходного блока. Аргументы переданные методу call, становяться аргументами для
блока, а возвращаемое значение блоком значение становится возвращаемым
значением метода call.
-------------------------------------------------------------------------------
Глава 6.5.3 - Арность Proc.

Арность proc или lambda - это количество ожидаемых ими аргументов.
-------------------------------------------------------------------------------
Глава 6.5.5 - Отличие lambda-объектов от proc-объектов.

Объект proc является блоком в форме объекта, и он ведет себя как блок.
Lambda-объект ведет себя как метод. Вызов proc-объекта похож на передачу
управления блоку, в то время как вызов lambda-объекта похож на вызов метода.
-------------------------------------------------------------------------------
Глава 6.5.5.1 - Инструкция return в блоках, proc- и lambda-объектах.

При использовании инструкции return в proc-объекте, происходит возврат не из
блока, а из метода вызваашего этот proc-объект. Если же return используется в
lambda-объекте, осуществляется возврат из самого lambda-объекта.
-------------------------------------------------------------------------------
Глава 6.6 - Замкнутые выражения.

Proc- и lambda-объекты являются замкнутыми выражениями. При создании proc- и
lambda-объектов получившийся Proc-объект содержит не только выполняемый блок,
но также и привязки ко всем переменным, которые используются блоком.

Возвращение lambda-объекта, который удерживает или "замыкает" параметр n:

def multiplier(n)
  lambda { |data| data.collect { |x| x * n } }
end
doubler = multiplier(2)      # Получаем lambda-объект, который умеет удваивать
puts doubler.call([1, 2, 3]) # Получим 2, 4, 6

Метод multiplier возвращает lambda-объект. Поскольку этот lambda-объект
используется за пределами области определения переменных, в которой он сам был
определен, он называется замкнутым выражением; он инкапсулирует или "замыкает"
(или просто удерживает) привязку к параметру n того метода, в которм он был
определен.
-------------------------------------------------------------------------------
Глава 6.6.1 - Замкнутые выражения и совместно используемые переменные.

Замкнутые выражения не только сохраняют значения переменных, на которые они
ссылаются, - они сохраняют сами переменные и продлевают время их существования.
Связывание является динамическим, и значения переменных выискиваются при
задействовании lambda- или proc-объектов.

Если два lambda-объекта определены в одной и той же области видимости
переменных, они имеют совместный доступ к переменным в этой области. Когда один
lambda-объект изменяет значение совместно используемой переменной, то новое
значение становиться доступно другому lambda-объекту.
-------------------------------------------------------------------------------
Глава 6.6.2 - Замкнутые выражения и связывание.

def multiplier(n)
  lambda { |data| data.collect { |x| x * n } }
end
doubler = multiplier(2)      # Замкнем 2 как значение переменной n
puts doubler.call([1, 2, 3]) # Вернет 2, 4, 6

Предположим мы хотим изменить n с 2 на 3:
eval('n=3', doubler.binding) # Или doubler.binding.eval('n=3') в Ruby 1.9
puts doubler.call([1, 2, 3]) # Вернет 3, 6, 9
-------------------------------------------------------------------------------
Глава 6.7 - Объекты класса Method.

Методы и блоки в Ruby - это выполняемые конструкции языка, но не объекты. Proc
и lambda являются объектными версиями блоков; они могут быть выполнены, а так
же ими можно манипулировать как данными.
-------------------------------------------------------------------------------
Глава 6.8.4 - Функции, обладающие мемоизацией.

Мемоизация - это термин функционального программирования, применяемый в
отношении кэширования результатов вызова функции. Если функция при передаче ей
одних и тех же аргументов всегда возвращает одно и то же значение, есть смысл
полагать, что такие же аргументы будут использованы неоднакратно, и если
вычисление осуществляется с затратой каких-либо существенных вычислительных
ресурсов, мемоизация может оказаться весьма полезной оптимизацией.

# Возвращение нового lambda-объекта, который кэширует результаты этой функции и
# вызывает фнкцию только в том случае, если предоставлены новые аргументы.
def memoize
  cache = {}                     # Пустой кэш, lambda захватывает его в свое
                                 # замкнутое пространство.
  lambda { |*args|
    unless cache.has_keys?(args) # Если результата для аргументов нет
      cache[args] = self[*args]  # вычисление и кэширование результата
    end
    cache[args]                  # Возвращение результата из кэша
  }
end
-------------------------------------------------------------------------------